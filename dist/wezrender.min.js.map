{"version":3,"sources":["webpack:///wezrender.min.js","webpack:///webpack/bootstrap 6c9a1e78787ba227f9da?f086","webpack:///./src/index.js?9552","webpack:///./src/core/bbox.js?db1b","webpack:///./src/core/vector.js?00a8","webpack:///./src/core/curve.js?0f52","webpack:///./src/container/Group.js?530d","webpack:///./src/core/util.js?bcd8","webpack:///./src/Element.js?dc56","webpack:///./src/core/guid.js?0d7f","webpack:///./src/mixin/Eventful.js?62d5","webpack:///./src/mixin/Transformable.js?b925","webpack:///./src/core/matrix.js?d2cc","webpack:///./src/mixin/Animatable.js?4772","webpack:///./src/animation/Animator.js?5d3c","webpack:///./src/animation/Clip.js?6fcf","webpack:///./src/animation/easing.js?3cbf","webpack:///./src/tool/color.js?21e3","webpack:///./src/core/log.js?53be","webpack:///./src/config.js?4264","webpack:///./src/core/BoundingRect.js?5a9f","webpack:///./src/graphic/shape/Arc.js?deec","webpack:///./src/graphic/Path.js?c25f","webpack:///./src/graphic/Displayable.js?98ab","webpack:///./src/graphic/Style.js?a48a","webpack:///./src/graphic/mixin/RectText.js?acb3","webpack:///./src/contain/text.js?23e1","webpack:///./src/core/PathProxy.js?ce28","webpack:///./src/contain/path.js?0424","webpack:///./src/contain/line.js?fb11","webpack:///./src/contain/cubic.js?c952","webpack:///./src/contain/quadratic.js?dd13","webpack:///./src/contain/arc.js?907b","webpack:///./src/contain/util.js?3a26","webpack:///./src/contain/windingLine.js?7361","webpack:///./src/graphic/Pattern.js?a36a","webpack:///./src/graphic/shape/BezierCurve.js?31ae","webpack:///./src/graphic/shape/Circle.js?7396","webpack:///./src/graphic/shape/Droplet.js?5807","webpack:///./src/graphic/shape/Ellipse.js?f8bb","webpack:///./src/graphic/shape/Heart.js?74ca","webpack:///./src/graphic/shape/Isogon.js?0cd2","webpack:///./src/graphic/shape/Line.js?2a9d","webpack:///./src/graphic/shape/Polyline.js?c9e2","webpack:///./src/graphic/helper/poly.js?b57d","webpack:///./src/graphic/helper/smoothSpline.js?5d1c","webpack:///./src/graphic/helper/smoothBezier.js?3668","webpack:///./src/graphic/shape/Polygon.js?495b","webpack:///./src/graphic/shape/Rect.js?b540","webpack:///./src/graphic/helper/roundRect.js?f68a","webpack:///./src/graphic/shape/Ring.js?ba2d","webpack:///./src/graphic/shape/Rose.js?a5f9","webpack:///./src/graphic/shape/Sector.js?4842","webpack:///./src/graphic/shape/Star.js?8f03","webpack:///./src/graphic/shape/Trochoid.js?43ad","webpack:///./src/graphic/Gradient.js?a9c6","webpack:///./src/graphic/LinearGradient.js?3983","webpack:///./src/graphic/RadialGradient.js?b2ec","webpack:///./src/graphic/Text.js?2a47","webpack:///./src/graphic/Image.js?e51a","webpack:///./src/animation/Animation.js?8f21","webpack:///./src/core/event.js?6d61","webpack:///./src/animation/requestAnimationFrame.js?d6d9","webpack:///./src/zrender.js?c270","webpack:///./src/Handler.js?57e2","webpack:///./src/mixin/Draggable.js?2703","webpack:///./src/Storage.js?8290","webpack:///./src/core/timsort.js?ad91","webpack:///./src/Painter.js?0eee","webpack:///./src/Layer.js?be02"],"names":["e","a","i","exports","modules","__webpack_require__","moduleId","installedModules","module","id","loaded","call","m","c","p","core","bbox","container","Group","shape","Arc","BezierCurve","Circle","Droplet","Ellipse","Heart","Isogon","Line","Polyline","Polygon","Rect","Ring","Rose","Sector","Star","Trochoid","graphic","Path","Gradient","LinearGradient","RadialGradient","Text","Image","Animation","zrender","vec2","curve","mathMin","Math","min","mathMax","max","mathSin","sin","mathCos","cos","start","create","end","extremity","PI2","PI","fromPoints","points","length","left","right","top","bottom","fromLine","x0","y0","x1","y1","xDim","yDim","fromCubic","x2","y2","x3","y3","cubicExtrema","cubicAt","n","Infinity","x","y","fromQuadratic","quadraticExtremum","quadraticAt","tx","ty","fromArc","rx","ry","startAngle","endAngle","anticlockwise","vec2Min","vec2Max","diff","abs","tmp","angle","ArrayCtor","Float32Array","Array","vector","out","copy","v","clone","set","b","add","v1","v2","scaleAndAdd","sub","len","sqrt","this","lenSquare","mul","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","applyTransform","lengthSquare","dist","distSquare","isAroundZero","val","EPSILON","isNotAroundZero","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","A","B","C","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","THREE_SQRT","t3","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","prev","next","d1","d2","interval","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticDerivativeAt","quadraticRootAt","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","pow","zrUtil","Element","BoundingRect","opts","key","hasOwnProperty","_children","__storage","__dirty","prototype","constructor","isGroup","type","silent","children","slice","childAt","idx","childOfName","name","childCount","child","parent","push","_doAdd","addBefore","nextSibling","indexOf","splice","remove","storage","zr","__zr","addToMap","addChildrenToStorage","refresh","delFromMap","delChildrenFromStorage","removeAll","eachChild","cb","context","traverse","dirty","getBoundingRect","includeChildren","rect","tmpRect","tmpMat","ignore","invisible","childRect","transform","getLocalTransform","union","inherits","source","result","typeStr","objToString","TYPED_ARRAY","from","BUILTIN_OBJECT","isDom","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuildInObject","mergeAll","targetAndSources","extend","defaults","overlay","array","value","clazz","baseClazz","F","clazzPrototype","prop","superClass","mixin","isArrayLike","data","each","obj","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","nodeType","ownerDocument","retrieve","values","Function","assert","condition","message","Error","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","util","noop","guid","Eventful","Transformable","Animatable","clipPath","drift","dx","dy","draggable","decomposeTransform","beforeUpdate","afterUpdate","update","updateTransform","attrKV","hide","show","attr","setClipPath","addSelfToZr","removeClipPath","__clipTarget","removeSelfFromZr","animators","animation","addAnimator","removeAnimator","idStart","arrySlice","_$handlers","one","event","handler","_h","h","ctx","on","isSilent","off","newList","l","trigger","argLen","triggerWithContext","matrix","mIdentity","identity","position","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","invTransform","invert","rotate","setTransform","dpr","restoreTransform","tmpTransform","sx","sy","atan2","getGlobalScale","transformCoordToLocal","transformCoordToGlobal","m1","m2","out0","out1","out2","out3","out4","out5","translate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","Animator","log","animate","path","loop","animatingShape","el","pathSplitted","split","animator","during","done","stopAnimation","forwardToLast","stop","animateTo","time","delay","easing","callback","count","_animateToShallow","objShallow","propertyCount","props","when","defaultGetter","defaultSetter","interpolateNumber","percent","interpolateString","interpolateArray","arrDim","len2","j","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isNaN","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","createTrackClip","oneTrackDone","keyframes","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","color","parse","lastValue","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","self","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","options","_life","_initialized","gap","onrestart","easingFuncs","step","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","round","clampCssAngle","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","colorStr","replace","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","lift","level","colorArr","stringify","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","config","debugMode","console","devicePixelRatio","width","height","v2ApplyTransform","other","lt","rb","lb","rt","maxX","maxY","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","contain","plain","cx","cy","r","clockwise","style","stroke","fill","buildPath","unitX","unitY","moveTo","arc","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","getGradient","_strokeGradient","setFillStyle","setStrokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","setScale","beginPath","setLineDashOffset","rebuildPath","lineWidth","setLineWidth","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","setShadow","lineCap","setLineCap","lineJoin","setLineJoin","miterLimit","setMiterLimit","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","strokeNoScale","getLineScale","localPos","pathData","containStroke","dirtyPath","animateShape","setShape","Sub","extendFrom","defaultShape","thisShape","init","Style","__clipPaths","RectText","z","z2","zlevel","dragging","culling","cursor","rectHover","progressive","beforeBrush","afterBrush","rectContain","coord","animateStyle","setStyle","useStyle","createLinearGradient","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","opacity","textFill","textStroke","textPosition","textBaseline","textAlign","textVerticalAlign","textDistance","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","setGlobalAlpha","globalCompositeOperation","otherStyle","newStyle","method","colorStops","addColorStop","offset","styleProto","parsePercent","maxValue","lastIndexOf","textContain","textRect","save","align","font","textFont","baseline","verticalAlign","lineHeight","res","adjustTextPositionOnRect","fontSize","setFontSize","textShadowColor","textLines","fillText","strokeText","restore","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textLineLen","textHeight","halfHeight","truncateText","containerWidth","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getWidth","CMD","M","Q","Z","min2","max2","mathAbs","hasTypedArray","_len","_ctx","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","getContext","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arcTo","radius","closePath","toStatic","lineDashSum","setData","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","line","_l","_a","_b","_s","image","repeat","_canvasPattern","createPattern","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","ox","oy","dStep","deg","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","pos","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","shift","roundRectHelper","r1","r2","r3","r4","total","r0","radian","xStart","yStart","ri","location","offsetX","offsetY","num","globalCoord","ZImage","drawImage","Dispatcher","requestAnimationFrame","stage","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","_update","Date","getTime","deferredEvents","deferredClips","_startLoop","pause","resume","clear","getBoundingClientRect","clientToLocal","calculate","defaultGetZrXY","box","zrX","clientX","zrY","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","attachEvent","removeEventListener","detachEvent","returnValue","cancelBubble","setTimeout","delInstance","instances","Handler","Storage","painterCtors","canvas","version","dom","wx","createCanvasContext","ZRender","dispose","getInstance","registerPainter","Ctor","rendererType","painter","handlerProxy","root","flush","_needsRefresh","oldDelFromMap","oldAddToMap","elId","get","getId","addRoot","delRoot","configLayer","zLevel","refreshImmediately","clearAnimation","getHeight","eventName","eventHandler","makeEventPacket","eveType","gestureEvent","pinchX","pinchY","pinchScale","zrByTouch","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","_downel","_upel","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","userSetClipPath","currentClipPath","parentClipPath","elements","_renderList","displayableSortFunc","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","Layer","Painter","_opts","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","getViewportRoot","paintAll","_paintList","_doPaintList","currentLayer","currentZLevel","scope","elZLevel","elFrame","__frame","getLayer","__unusedCount","_doPaintEl","forcePaint","prevClipLayer","prevElClipPaths","draw","eachLayer","eachBuildinLayer","isBuildin","getLayers","_clearLayer","layerConfig","_domRoot","ctxBack","clearColor","motionBlur","lastFrameAlpha","elCount","clearAll","clearRect","clearColorGradientOrPattern","__canvasGradient","fillRect"],"mappings":"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","file":"wezrender.min.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\tvar core = {\r\n\t\tbbox             :     __webpack_require__(1),\r\n\t};\r\n\t\r\n\tvar container = {\r\n\t\tGroup            :     __webpack_require__(4),\r\n\t}\r\n\t\r\n\tvar shape = {\r\n\t    Arc             :     __webpack_require__(19),\r\n\t    BezierCurve     :     __webpack_require__(34),\r\n\t    Circle          :     __webpack_require__(35),\r\n\t    Droplet         :     __webpack_require__(36),\r\n\t    Ellipse         :     __webpack_require__(37),\r\n\t    Heart           :     __webpack_require__(38),\r\n\t    Isogon          :     __webpack_require__(39),\r\n\t    Line            :     __webpack_require__(40),    \r\n\t    Polyline        :     __webpack_require__(41),\r\n\t    Polygon         :     __webpack_require__(45),\r\n\t    Rect            :     __webpack_require__(46),\r\n\t    Ring            :     __webpack_require__(48),\r\n\t    Rose            :     __webpack_require__(49),\r\n\t    Sector          :     __webpack_require__(50),\r\n\t    Star            :     __webpack_require__(51),\r\n\t    Trochoid        :     __webpack_require__(52)\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\tvar graphic = {\r\n\t\t\r\n\t    shape           :     shape,\r\n\t\r\n\t    Path        \t:     __webpack_require__(20),    \r\n\t\r\n\t    Gradient        :     __webpack_require__(53),    \r\n\t    LinearGradient  :     __webpack_require__(54),   \r\n\t    RadialGradient  :     __webpack_require__(55),   \r\n\t\r\n\t    Text            :     __webpack_require__(56),\r\n\t\tImage           :     __webpack_require__(57),\r\n\t}\r\n\t\r\n\tvar animation = {\r\n\t    Animation       :     __webpack_require__(58),    \r\n\t}\r\n\t\r\n\tmodule.exports = {\r\n\t    zrender         :     __webpack_require__(61),\r\n\t\t\r\n\t\tcore\t\t\t:     core,\r\n\t\tcontainer\t\t:     container,\r\n\t\r\n\t    graphic         :     graphic\r\n\t    \r\n\t    \r\n\t \r\n\t};\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(2);\n\t    var curve = __webpack_require__(3);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * \n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} \n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(2);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * GroupGroup\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t    var Element = __webpack_require__(6);\n\t    var BoundingRect = __webpack_require__(18);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         *  index \n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *  nextSibling \n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t   \n\t\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t      \n\t    \n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(7);\n\t    var Eventful = __webpack_require__(8);\n\t    var Transformable = __webpack_require__(9);\n\t    var Animatable = __webpack_require__(11);\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * \n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * \n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender  element  zrender \n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * (shape) Group \n\t         * \n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\t\t\t\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * trigger\n\t         *\n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} [handler] \n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} type \n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * context, context\n\t         * @param {string} type \n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(10);\n\t    var vector = __webpack_require__(2);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * \n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(12);\n\t    var util = __webpack_require__(5);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(16);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} path a.b.c\n\t         * @param {boolean} [loop] \n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\t\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\t\t\t\n\t\t\t\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(13);\n\t    var color = __webpack_require__(15);\n\t    var util = __webpack_require__(5);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @param  {Object} props key-value\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t\t\t\t\n\t\t\t\t\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\t\t\t\n\t\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param  {string|Function} easing\n\t         *         {@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\t\t\t\n\t\t\t\t\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t\t\t\t\n\t\t\t\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @config target onframe\n\t * @config life(1000) \n\t * @config delay(0) \n\t * @config loop(true)\n\t * @config gap(0) \n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(14);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t\t\t\t\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t\t\t\t\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\t\t\t\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t\t\t\t\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\t\n\t                this[eventType](this._target, arg);\n\t            }\n\t\t\t\t\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // t^3\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // t^4\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // t^5\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // sin(t)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 2^t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // sqrt(1-t^2)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(17);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        \n\t    \n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    \n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debugcatchBrushExceptiontrue\n\t         * 0 : debug\n\t         * 1 : \n\t         * 2 : \n\t         */\n\t        debugMode: 2,\n\t\n\t        // retina \n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(2);\n\t    var matrix = __webpack_require__(10);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // \n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Arc\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'arc',\n\t\n\t    shape: {\n\t\n\t        cx: 0,\n\t\n\t        cy: 0,\n\t\n\t        r: 0,\n\t\n\t        startAngle: 0,\n\t\n\t        endAngle: Math.PI * 2,\n\t\n\t        clockwise: true\n\t    },\n\t\n\t    style: {\n\t\n\t        stroke: '#000000',\n\t\n\t        fill: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var r = Math.max(shape.r, 0);\n\t        var startAngle = shape.startAngle;\n\t        var endAngle = shape.endAngle;\n\t        var clockwise = shape.clockwise;\n\t\n\t        var unitX = Math.cos(startAngle);\n\t        var unitY = Math.sin(startAngle);\n\t\n\t        ctx.moveTo(unitX * r + x, unitY * r + y);\n\t        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t    }\n\t});\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t var log = __webpack_require__(16);\n\t\n\t\n\t    var Displayable = __webpack_require__(21);\n\t    var zrUtil = __webpack_require__(5);\n\t    var PathProxy = __webpack_require__(25);\n\t    var pathContain = __webpack_require__(26);\n\t\n\t    var Pattern = __webpack_require__(33);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\t\t\t\t\t\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.setFillStyle(this._fillGradient);\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.setFillStyle(getCanvasPattern.call(fill, ctx));\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.setStrokeStyle(this._strokeGradient);\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.setStrokeStyle(getCanvasPattern.call(stroke, ctx));\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\t\t\t\n\t\t\t\t/*** we ***/\n\t\t\t\tvar lineWidth = style.lineWidth;\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tctx.setLineWidth(lineWidth);\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar shadowBlur = style.shadowBlur;\n\t\t\t\tvar shadowOffsetX = style.shadowOffsetX || 0;\n\t\t\t\tvar shadowOffsetY = style.shadowOffsetY || 0;\n\t\t\t\tvar shadowColor = style.shadowColor || '#000000';\n\t\t\t\t\n\t\t\t\tif (shadowBlur) {\n\t\t\t\t\tctx.setShadow(shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar lineCap = style.lineCap;\n\t\t\t\t\n\t\t\t\tif (lineCap) {\n\t\t\t\t\tctx.setLineCap(lineCap);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar lineJoin = style.lineJoin;\n\t\t\t\t\n\t\t\t\tif (lineJoin) {\n\t\t\t\t\tctx.setLineJoin(lineJoin);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar miterLimit = style.miterLimit;\n\t\t\t\t\n\t\t\t\tif (miterLimit) {\n\t\t\t\t\tctx.setMiterLimit(miterLimit);\n\t\t\t\t}\n\t\n\t\t\t\t/*** we ***/\n\t            \n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    var Style = __webpack_require__(22);\n\t\n\t    var Element = __webpack_require__(6);\n\t    var RectText = __webpack_require__(23);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable Painter \n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * zlevelcanvas\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * \n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * \n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         *  x, y \n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         *  x, y \n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO,  bind \n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t var log = __webpack_require__(16);\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\t\t\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t         textFill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            } \n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {                \n\t                ctx.setFillStyle(style.fill);\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.setStrokeStyle(style.stroke);\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.setGlobalAlpha(style.opacity == null ? 1 : style.opacity);\n\t            }\n\t  \n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\t\t\t\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t\t\t\t\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\t\n\t\t\t\t\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\tvar log = __webpack_require__(16);\n\t    var textContain = __webpack_require__(24);\n\t    var BoundingRect = __webpack_require__(18);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\t\t\t\n\t            var style = this.style;\n\t\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\t\n\t\n\t\t\t\t\t\t\t\n\t            // Transform rect to view space\n\t\t\t\t\n\t            var transform = this.transform;\n\t\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\t\t\t\t\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t\t\t\t\t\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\t\t\t\n\t\t\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.setFillStyle(textFill));\n\t            textStroke && (ctx.setStrokeStyle(textStroke));\n\t\n\t\t\t\t\n\t            // TODO Invalid font\n\t\t\t\tvar fontSize = parseInt(\n\t\t\t\t\t(font || '18 simsun').split(' ')[0].replace('px', ''));\n\t            ctx.setFontSize(fontSize);\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t\t\t\t\n\t\t\t\t/*** we ***/\n\t\t\t\tctx.setShadow(style.textShadowOffsetX, style.textShadowOffsetY, style.textShadowBlur, style.textShadowColor || 'rgba(0, 0, 0, 1)');\n\t            /*** we ***/\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\t\n\t\t\t\t\n\t\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(5);\n\t    var BoundingRect = __webpack_require__(18);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\t\tvar fontSize = parseInt(\n\t\t\t\t(textFont || '18 simsun').split(' ')[0].replace('px', ''));\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], fontSize).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, fontSize) {\n\t           /*** we ***/\n\t\t\t   // MeasureText always return a fixed value   \n\t\t\t   return { width: 18}\n\t\t\t   /*** we ***/\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path `buildPath``ctx`, pathpathCommands\n\t *  isInsidePath boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(3);\n\t    var vec2 = __webpack_require__(2);\n\t    var bbox = __webpack_require__(1);\n\t    var BoundingRect = __webpack_require__(18);\n\t    var dpr = __webpack_require__(17).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context  rebuildPath  fill\n\t         * stroke \n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         * \n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         *  Float32Array \n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo  subpath, \n\t                        //  closePath \n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc \n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc \n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var line = __webpack_require__(27);\n\t    var cubic = __webpack_require__(28);\n\t    var quadratic = __webpack_require__(29);\n\t    var arc = __webpack_require__(30);\n\t    var normalizeRadian = __webpack_require__(31).normalizeRadian;\n\t    var curve = __webpack_require__(3);\n\t\n\t    var windingLine = __webpack_require__(32);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // \n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc \n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                //  subpath \n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE  L, C, Q  NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    //  arc \n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // \n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr scale, x\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        //  subpath \n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(3);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(3);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(31).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\tvar curveTool = __webpack_require__(3);\n\tvar vec2 = __webpack_require__(2);\n\tvar quadraticSubdivide = curveTool.quadraticSubdivide;\n\tvar cubicSubdivide = curveTool.cubicSubdivide;\n\tvar quadraticAt = curveTool.quadraticAt;\n\tvar cubicAt = curveTool.cubicAt;\n\tvar quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\tvar cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\tvar out = [];\n\t\n\tfunction someVectorAt(shape, t, isTangent) {\n\t    var cpx2 = shape.cpx2;\n\t    var cpy2 = shape.cpy2;\n\t    if (cpx2 === null || cpy2 === null) {\n\t        return [\n\t            (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t            (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t        ];\n\t    }\n\t    else {\n\t        return [\n\t            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t        ];\n\t    }\n\t}\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'bezier-curve',\n\t\n\t    shape: {\n\t        x1: 0,\n\t        y1: 0,\n\t        x2: 0,\n\t        y2: 0,\n\t        cpx1: 0,\n\t        cpy1: 0,\n\t        // cpx2: 0,\n\t        // cpy2: 0\n\t\n\t        // Curve show percent, for animating\n\t        percent: 1\n\t    },\n\t\n\t    style: {\n\t        stroke: '#000000',\n\t        fill: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x1 = shape.x1;\n\t        var y1 = shape.y1;\n\t        var x2 = shape.x2;\n\t        var y2 = shape.y2;\n\t        var cpx1 = shape.cpx1;\n\t        var cpy1 = shape.cpy1;\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        var percent = shape.percent;\n\t        if (percent === 0) {\n\t            return;\n\t        }\n\t\n\t        ctx.moveTo(x1, y1);\n\t\n\t        if (cpx2 == null || cpy2 == null) {\n\t            if (percent < 1) {\n\t                quadraticSubdivide(\n\t                    x1, cpx1, x2, percent, out\n\t                );\n\t                cpx1 = out[1];\n\t                x2 = out[2];\n\t                quadraticSubdivide(\n\t                    y1, cpy1, y2, percent, out\n\t                );\n\t                cpy1 = out[1];\n\t                y2 = out[2];\n\t            }\n\t\n\t            ctx.quadraticCurveTo(\n\t                cpx1, cpy1,\n\t                x2, y2\n\t            );\n\t        }\n\t        else {\n\t            if (percent < 1) {\n\t                cubicSubdivide(\n\t                    x1, cpx1, cpx2, x2, percent, out\n\t                );\n\t                cpx1 = out[1];\n\t                cpx2 = out[2];\n\t                x2 = out[3];\n\t                cubicSubdivide(\n\t                    y1, cpy1, cpy2, y2, percent, out\n\t                );\n\t                cpy1 = out[1];\n\t                cpy2 = out[2];\n\t                y2 = out[3];\n\t            }\n\t            ctx.bezierCurveTo(\n\t                cpx1, cpy1,\n\t                cpx2, cpy2,\n\t                x2, y2\n\t            );\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Get point at percent\n\t     * @param  {number} t\n\t     * @return {Array.<number>}\n\t     */\n\t    pointAt: function (t) {\n\t        return someVectorAt(this.shape, t, false);\n\t    },\n\t\n\t    /**\n\t     * Get tangent at percent\n\t     * @param  {number} t\n\t     * @return {Array.<number>}\n\t     */\n\t    tangentAt: function (t) {\n\t        var p = someVectorAt(this.shape, t, true);\n\t        return vec2.normalize(p, p);\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/Circle\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'circle',\n\t\n\t    shape: {\n\t        cx: 0,\n\t        cy: 0,\n\t        r: 0\n\t    },\n\t\n\t\n\t    buildPath: function (ctx, shape, inBundle) {\n\t        // Better stroking in ShapeBundle\n\t        // Always do it may have performence issue ( fill may be 2x more cost)\n\t        if (inBundle) {\n\t            ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t        }\n\t        // Better stroking in ShapeBundle\n\t        // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Droplet\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'droplet',\n\t\n\t    shape: {\n\t        cx: 0, cy: 0,\n\t        width: 0, height: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var a = shape.width;\n\t        var b = shape.height;\n\t\n\t        ctx.moveTo(x, y + a);\n\t        ctx.bezierCurveTo(\n\t            x + a,\n\t            y + a,\n\t            x + a * 3 / 2,\n\t            y - a / 3,\n\t            x,\n\t            y - b\n\t        );\n\t        ctx.bezierCurveTo(\n\t            x - a * 3 / 2,\n\t            y - a / 3,\n\t            x - a,\n\t            y + a,\n\t            x,\n\t            y + a\n\t        );\n\t        ctx.closePath();\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ellipse\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'ellipse',\n\t\n\t    shape: {\n\t        cx: 0, cy: 0,\n\t        rx: 0, ry: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var k = 0.5522848;\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var a = shape.rx;\n\t        var b = shape.ry;\n\t        var ox = a * k; // \n\t        var oy = b * k; // \n\t        // \n\t        ctx.moveTo(x - a, y);\n\t        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\n\t        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\n\t        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\n\t        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\n\t        ctx.closePath();\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Heart\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'heart',\n\t\n\t    shape: {\n\t        cx: 0,\n\t        cy: 0,\n\t        width: 0,\n\t        height: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var a = shape.width;\n\t        var b = shape.height;\n\t        ctx.moveTo(x, y);\n\t        ctx.bezierCurveTo(\n\t            x + a / 2, y - b * 2 / 3,\n\t            x + a * 2, y + b / 3,\n\t            x, y + b\n\t        );\n\t        ctx.bezierCurveTo(\n\t            x - a * 2, y + b / 3,\n\t            x - a / 2, y - b * 2 / 3,\n\t            x, y\n\t        );\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/Isogon\n\t * @author sushuang (, sushuang0322@gmail.com)\n\t */\n\t\n\tvar PI = Math.PI;\n\tvar sin = Math.sin;\n\tvar cos = Math.cos;\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'isogon',\n\t\n\t    shape: {\n\t        x: 0, y: 0,\n\t        r: 0, n: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var n = shape.n;\n\t        if (!n || n < 2) {\n\t            return;\n\t        }\n\t\n\t        var x = shape.x;\n\t        var y = shape.y;\n\t        var r = shape.r;\n\t\n\t        var dStep = 2 * PI / n;\n\t        var deg = -PI / 2;\n\t\n\t        ctx.moveTo(x + r * cos(deg), y + r * sin(deg));\n\t        for (var i = 0, end = n - 1; i < end; i++) {\n\t            deg += dStep;\n\t            ctx.lineTo(x + r * cos(deg), y + r * sin(deg));\n\t        }\n\t\n\t        ctx.closePath();\n\t\n\t        return;\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'line',\n\t\n\t    shape: {\n\t        // Start point\n\t        x1: 0,\n\t        y1: 0,\n\t        // End point\n\t        x2: 0,\n\t        y2: 0,\n\t\n\t        percent: 1\n\t    },\n\t\n\t    style: {\n\t        stroke: '#000000',\n\t        fill: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x1 = shape.x1;\n\t        var y1 = shape.y1;\n\t        var x2 = shape.x2;\n\t        var y2 = shape.y2;\n\t        var percent = shape.percent;\n\t\n\t        if (percent === 0) {\n\t            return;\n\t        }\n\t\n\t        ctx.moveTo(x1, y1);\n\t\n\t        if (percent < 1) {\n\t            x2 = x1 * (1 - percent) + x2 * percent;\n\t            y2 = y1 * (1 - percent) + y2 * percent;\n\t        }\n\t        ctx.lineTo(x2, y2);\n\t    },\n\t\n\t    /**\n\t     * Get point at percent\n\t     * @param  {number} percent\n\t     * @return {Array.<number>}\n\t     */\n\t    pointAt: function (p) {\n\t        var shape = this.shape;\n\t        return [\n\t            shape.x1 * (1 - p) + shape.x2 * p,\n\t            shape.y1 * (1 - p) + shape.y2 * p\n\t        ];\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\tvar polyHelper = __webpack_require__(42);\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'polyline',\n\t\n\t    shape: {\n\t        points: null,\n\t\n\t        smooth: false,\n\t\n\t        smoothConstraint: null\n\t    },\n\t\n\t    style: {\n\t        stroke: '#000000',\n\t\n\t        fill: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        polyHelper.buildPath(ctx, shape, false);\n\t    }\n\t});\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(43);\n\t    var smoothBezier = __webpack_require__(44);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline \n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(2);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(2);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/Polygon\n\t */\n\t\n\tvar polyHelper = __webpack_require__(42);\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'polygon',\n\t\n\t    shape: {\n\t        points: null,\n\t\n\t        smooth: false,\n\t\n\t        smoothConstraint: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        polyHelper.buildPath(ctx, shape, true);\n\t    }\n\t});\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\tvar roundRectHelper = __webpack_require__(47);\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'rect',\n\t\n\t    shape: {\n\t        // r1r2r3r4\n\t        // r1          [1, 1, 1, 1]\n\t        // r[1]        [1, 1, 1, 1]\n\t        // r[1, 2]     [1, 2, 1, 2]\n\t        // r[1, 2, 3]  [1, 2, 3, 2]\n\t        r: 0,\n\t\n\t        x: 0,\n\t        y: 0,\n\t        width: 0,\n\t        height: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x = shape.x;\n\t        var y = shape.y;\n\t        var width = shape.width;\n\t        var height = shape.height;\n\t        if (!shape.r) {\n\t            ctx.rect(x, y, width, height);\n\t        }\n\t        else {\n\t            roundRectHelper.buildPath(ctx, shape);\n\t        }\n\t        ctx.closePath();\n\t        return;\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'ring',\n\t\n\t    shape: {\n\t        cx: 0,\n\t        cy: 0,\n\t        r: 0,\n\t        r0: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var PI2 = Math.PI * 2;\n\t        ctx.moveTo(x + shape.r, y);\n\t        ctx.arc(x, y, shape.r, 0, PI2, false);\n\t        ctx.moveTo(x + shape.r0, y);\n\t        ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rose\n\t */\n\t\n\tvar sin = Math.sin;\n\tvar cos = Math.cos;\n\tvar radian = Math.PI / 180;\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'rose',\n\t\n\t    shape: {\n\t        cx: 0,\n\t        cy: 0,\n\t        r: [],\n\t        k: 0,\n\t        n: 1\n\t    },\n\t\n\t    style: {\n\t        stroke: '#000000',\n\t        fill: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x;\n\t        var y;\n\t        var R = shape.r;\n\t        var r;\n\t        var k = shape.k;\n\t        var n = shape.n;\n\t\n\t        var x0 = shape.cx;\n\t        var y0 = shape.cy;\n\t\n\t        ctx.moveTo(x0, y0);\n\t\n\t        for (var i = 0, len = R.length; i < len; i++) {\n\t            r = R[i];\n\t\n\t            for (var j = 0; j <= 360 * n; j++) {\n\t                x = r\n\t                    * sin(k / n * j % 360 * radian)\n\t                    * cos(j * radian)\n\t                    + x0;\n\t                y = r\n\t                    * sin(k / n * j % 360 * radian)\n\t                    * sin(j * radian)\n\t                    + y0;\n\t                ctx.lineTo(x, y);\n\t            }\n\t        }\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\tvar Path = __webpack_require__(20);\n\t\n\tmodule.exports = Path.extend({\n\t\n\t    type: 'sector',\n\t\n\t    shape: {\n\t\n\t        cx: 0,\n\t\n\t        cy: 0,\n\t\n\t        r0: 0,\n\t\n\t        r: 0,\n\t\n\t        startAngle: 0,\n\t\n\t        endAngle: Math.PI * 2,\n\t\n\t        clockwise: true\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var r0 = Math.max(shape.r0 || 0, 0);\n\t        var r = Math.max(shape.r, 0);\n\t        var startAngle = shape.startAngle;\n\t        var endAngle = shape.endAngle;\n\t        var clockwise = shape.clockwise;\n\t\n\t        var unitX = Math.cos(startAngle);\n\t        var unitY = Math.sin(startAngle);\n\t\n\t        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t        ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t        ctx.lineTo(\n\t            Math.cos(endAngle) * r0 + x,\n\t            Math.sin(endAngle) * r0 + y\n\t        );\n\t\n\t        if (r0 !== 0) {\n\t            ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t        }\n\t\n\t        ctx.closePath();\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * nn>3\n\t * @module zrender/graphic/shape/Star\n\t */\n\t\n\tvar PI = Math.PI;\n\t\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'star',\n\t\n\t    shape: {\n\t        cx: 0,\n\t        cy: 0,\n\t        n: 3,\n\t        r0: null,\n\t        r: 0\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t\n\t        var n = shape.n;\n\t        if (!n || n < 2) {\n\t            return;\n\t        }\n\t\n\t        var x = shape.cx;\n\t        var y = shape.cy;\n\t        var r = shape.r;\n\t        var r0 = shape.r0;\n\t\n\t        // \n\t        if (r0 == null) {\n\t            r0 = n > 4\n\t                // \n\t                // r0\n\t                ? r * cos(2 * PI / n) / cos(PI / n)\n\t                // \n\t                : r / 3;\n\t        }\n\t\n\t        var dStep = PI / n;\n\t        var deg = -PI / 2;\n\t        var xStart = x + r * cos(deg);\n\t        var yStart = y + r * sin(deg);\n\t        deg += dStep;\n\t\n\t        // inside\n\t        ctx.moveTo(xStart, yStart);\n\t        for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\n\t            ri = i % 2 === 0 ? r0 : r;\n\t            ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));\n\t            deg += dStep;\n\t        }\n\t\n\t        ctx.closePath();\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Trochoid\n\t */\n\t\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\t\n\tmodule.exports = __webpack_require__(20).extend({\n\t\n\t    type: 'trochoid',\n\t\n\t    shape: {\n\t        cx: 0,\n\t        cy: 0,\n\t        r: 0,\n\t        r0: 0,\n\t        d: 0,\n\t        location: 'out'\n\t    },\n\t\n\t    style: {\n\t        stroke: '#000000',\n\t\n\t        fill: null\n\t    },\n\t\n\t    buildPath: function (ctx, shape) {\n\t        var x1;\n\t        var y1;\n\t        var x2;\n\t        var y2;\n\t        var R = shape.r;\n\t        var r = shape.r0;\n\t        var d = shape.d;\n\t        var offsetX = shape.cx;\n\t        var offsetY = shape.cy;\n\t        var delta = shape.location == 'out' ? 1 : -1;\n\t\n\t        if (shape.location && R <= r) {\n\t            return;\n\t        }\n\t\n\t        var num = 0;\n\t        var i = 1;\n\t        var theta;\n\t\n\t        x1 = (R + delta * r) * cos(0)\n\t            - delta * d * cos(0) + offsetX;\n\t        y1 = (R + delta * r) * sin(0)\n\t            - d * sin(0) + offsetY;\n\t\n\t        ctx.moveTo(x1, y1);\n\t\n\t        // i\n\t        do {\n\t            num++;\n\t        }\n\t        while ((r * num) % (R + delta * r) !== 0);\n\t\n\t        do {\n\t            theta = Math.PI / 180 * i;\n\t            x2 = (R + delta * r) * cos(theta)\n\t                - delta * d * cos((R / r + delta) * theta)\n\t                + offsetX;\n\t            y2 = (R + delta * r) * sin(theta)\n\t                - d * sin((R / r + delta) * theta)\n\t                + offsetY;\n\t            ctx.lineTo(x2, y2);\n\t            i++;\n\t        }\n\t        while (i <= (r * num) / (R + delta * r) * 360);\n\t\n\t    }\n\t});\n\t\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @param {Array.<Object>} colorStops\n\t */\n\tvar Gradient = function (colorStops) {\n\t\n\t    this.colorStops = colorStops || [];\n\t};\n\t\n\tGradient.prototype = {\n\t\n\t    constructor: Gradient,\n\t\n\t    addColorStop: function (offset, color) {\n\t        this.colorStops.push({\n\t\n\t            offset: offset,\n\t\n\t            color: color\n\t        });\n\t    }\n\t};\n\t\n\tmodule.exports = Gradient;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Gradient = __webpack_require__(53);\n\t\n\t/**\n\t * x, y, x2, y2 are all percent from 0 to 1\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @param {number} [x2=1]\n\t * @param {number} [y2=0]\n\t * @param {Array.<Object>} colorStops\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t    this.x = x == null ? 0 : x;\n\t\n\t    this.y = y == null ? 0 : y;\n\t\n\t    this.x2 = x2 == null ? 1 : x2;\n\t\n\t    this.y2 = y2 == null ? 0 : y2;\n\t\n\t    // Can be cloned\n\t    this.type = 'linear';\n\t\n\t    // If use global coord\n\t    this.global = globalCoord || false;\n\t\n\t    Gradient.call(this, colorStops);\n\t};\n\t\n\tLinearGradient.prototype = {\n\t\n\t    constructor: LinearGradient\n\t};\n\t\n\tzrUtil.inherits(LinearGradient, Gradient);\n\t\n\tmodule.exports = LinearGradient;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Gradient = __webpack_require__(53);\n\t\n\t/**\n\t * x, y, r are all percent from 0 to 1\n\t * @param {number} [x=0.5]\n\t * @param {number} [y=0.5]\n\t * @param {number} [r=0.5]\n\t * @param {Array.<Object>} [colorStops]\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t    this.x = x == null ? 0.5 : x;\n\t\n\t    this.y = y == null ? 0.5 : y;\n\t\n\t    this.r = r == null ? 0.5 : r;\n\t\n\t    // Can be cloned\n\t    this.type = 'radial';\n\t\n\t    // If use global coord\n\t    this.global = globalCoord || false;\n\t\n\t    Gradient.call(this, colorStops);\n\t};\n\t\n\tRadialGradient.prototype = {\n\t\n\t    constructor: RadialGradient\n\t};\n\t\n\tzrUtil.inherits(RadialGradient, Gradient);\n\t\n\tmodule.exports = RadialGradient;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\tvar Displayable = __webpack_require__(21);\n\tvar zrUtil = __webpack_require__(5);\n\tvar textContain = __webpack_require__(24);\n\t\n\t/**\n\t * @alias zrender/graphic/Text\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tvar Text = function (opts) {\n\t    Displayable.call(this, opts);\n\t};\n\t\n\tText.prototype = {\n\t\n\t    constructor: Text,\n\t\n\t    type: 'text',\n\t\n\t    brush: function (ctx, prevEl) {\n\t        var style = this.style;\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t        // Convert to string\n\t        var text = style.text;\n\t\n\t        // Convert to string\n\t        text != null && (text += '');\n\t\n\t        // Always bind style\n\t        style.bind(ctx, this, prevEl);\n\t\n\t        if (text) {\n\t\n\t            this.setTransform(ctx);\n\t\n\t            var textBaseline;\n\t            var textAlign = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            if (style.textVerticalAlign) {\n\t                var rect = textContain.getBoundingRect(\n\t                    text, font, style.textAlign, 'top'\n\t                );\n\t                // Ignore textBaseline\n\t                textBaseline = 'middle';\n\t                switch (style.textVerticalAlign) {\n\t                    case 'middle':\n\t                        y -= rect.height / 2 - rect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= rect.height - rect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += rect.lineHeight / 2;\n\t                }\n\t            }\n\t            else {\n\t                textBaseline = style.textBaseline;\n\t            }\t\t\t\n\t\t\t\n\t            // TODO Invalid font\t\t\t\n\t\t\t\tvar fontSize = parseInt(\n\t\t\t\t\t(font || '18 simsun').split(' ')[0].replace('px', ''));\n\t\t\t\tctx.setFontSize(fontSize);\n\t\n\t            ctx.textAlign = textAlign || 'left';\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            if (ctx.textAlign !== textAlign) {\n\t                ctx.textAlign = 'left';\n\t            }\n\t            ctx.textBaseline = textBaseline || 'alphabetic';\n\t            // Use canvas default alphabetic baseline\n\t            if (ctx.textBaseline !== textBaseline) {\n\t                ctx.textBaseline = 'alphabetic';\n\t            }\n\t\n\t            var lineHeight = textContain.measureText('', fontSize).width;\n\t\n\t            var textLines = text.split('\\n');\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                \n\t                style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                \n\t                style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                y += lineHeight;\n\t            }\n\t\n\t            this.restoreTransform(ctx);\n\t        }\n\t    },\n\t\n\t    getBoundingRect: function () {\n\t        if (!this._rect) {\n\t            var style = this.style;\n\t            var textVerticalAlign = style.textVerticalAlign;\n\t            var rect = textContain.getBoundingRect(\n\t                style.text + '', style.textFont || style.font, style.textAlign,\n\t                textVerticalAlign ? 'top' : style.textBaseline\n\t            );\n\t            switch (textVerticalAlign) {\n\t                case 'middle':\n\t                    rect.y -= rect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    rect.y -= rect.height;\n\t                    break;\n\t            }\n\t            rect.x += style.x || 0;\n\t            rect.y += style.y || 0;\n\t            this._rect = rect;\n\t        }\n\t        return this._rect;\n\t    }\n\t};\n\t\n\tzrUtil.inherits(Text, Displayable);\n\t\n\tmodule.exports = Text;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\tvar Displayable = __webpack_require__(21);\n\tvar BoundingRect = __webpack_require__(18);\n\tvar zrUtil = __webpack_require__(5);\n\t\n\t/**\n\t * @alias zrender/graphic/Image\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tfunction ZImage(opts) {\n\t    Displayable.call(this, opts);\n\t}\n\t\n\tZImage.prototype = {\n\t\n\t    constructor: ZImage,\n\t\n\t    type: 'image',\n\t\n\t    brush: function (ctx, prevEl) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Must bind each time\n\t        style.bind(ctx, this, prevEl);\n\t\n\t        var width = style.width;\n\t        var height = style.height;\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        // transform\n\t        this.setTransform(ctx);\n\t\n\t        ctx.drawImage(\n\t            image,\n\t            x, y, width, height\n\t        );\n\t\n\t        // Draw rect text\n\t        if (style.text != null) {\n\t            this.drawRectText(ctx, this.getBoundingRect());\n\t        }\n\t\n\t    },\n\t\n\t    getBoundingRect: function () {\n\t        var style = this.style;\n\t        if (!this._rect) {\n\t            this._rect = new BoundingRect(\n\t                style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t            );\n\t        }\n\t        return this._rect;\n\t    }\n\t};\n\t\n\tzrUtil.inherits(ZImage, Displayable);\n\t\n\tmodule.exports = ZImage;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * , \n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\tvar util = __webpack_require__(5);\n\tvar Dispatcher = __webpack_require__(59).Dispatcher;\n\t\n\tvar requestAnimationFrame = __webpack_require__(60);\n\t\n\tvar Animator = __webpack_require__(12);\n\t/**\n\t * @typedef {Object} IZRenderStage\n\t * @property {Function} update\n\t */\n\t\n\t/**\n\t * @alias module:zrender/animation/Animation\n\t * @constructor\n\t * @param {Object} [options]\n\t * @param {Function} [options.onframe]\n\t * @param {IZRenderStage} [options.stage]\n\t * @example\n\t *     var animation = new Animation();\n\t *     var obj = {\n\t *         x: 100,\n\t *         y: 100\n\t *     };\n\t *     animation.animate(node.position)\n\t *         .when(1000, {\n\t *             x: 500,\n\t *             y: 500\n\t *         })\n\t *         .when(2000, {\n\t *             x: 100,\n\t *             y: 100\n\t *         })\n\t *         .start('spline');\n\t */\n\tvar Animation = function (options) {\n\t\n\t    options = options || {};\n\t\n\t    this.stage = options.stage || {};\n\t\n\t    this.onframe = options.onframe || function () { };\n\t\n\t    // private properties\n\t    this._clips = [];\n\t\n\t    this._running = false;\n\t\n\t    this._time;\n\t\n\t    this._pausedTime;\n\t\n\t    this._pauseStart;\n\t\n\t    this._paused = false;\n\t\n\t    Dispatcher.call(this);\n\t};\n\t\n\tAnimation.prototype = {\n\t\n\t    constructor: Animation,\n\t    /**\n\t     *  clip\n\t     * @param {module:zrender/animation/Clip} clip\n\t     */\n\t    addClip: function (clip) {\n\t        this._clips.push(clip);\n\t    },\n\t    /**\n\t     *  animator\n\t     * @param {module:zrender/animation/Animator} animator\n\t     */\n\t    addAnimator: function (animator) {\n\t        animator.animation = this;\n\t        var clips = animator.getClips();\n\t        for (var i = 0; i < clips.length; i++) {\n\t            this.addClip(clips[i]);\n\t        }\n\t    },\n\t    /**\n\t     * \n\t     * @param {module:zrender/animation/Clip} clip\n\t     */\n\t    removeClip: function (clip) {\n\t        var idx = util.indexOf(this._clips, clip);\n\t        if (idx >= 0) {\n\t            this._clips.splice(idx, 1);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * \n\t     * @param {module:zrender/animation/Animator} animator\n\t     */\n\t    removeAnimator: function (animator) {\n\t        var clips = animator.getClips();\n\t        for (var i = 0; i < clips.length; i++) {\n\t            this.removeClip(clips[i]);\n\t        }\n\t        animator.animation = null;\n\t    },\n\t\n\t    _update: function () {\n\t\n\t\n\t        var time = new Date().getTime() - this._pausedTime;\n\t        var delta = time - this._time;\n\t        var clips = this._clips;\n\t        var len = clips.length;\n\t\n\t        var deferredEvents = [];\n\t        var deferredClips = [];\n\t        for (var i = 0; i < len; i++) {\n\t            var clip = clips[i];\n\t            var e = clip.step(time);\n\t            // Throw out the events need to be called after\n\t            // stage.update, like destroy\n\t            if (e) {\n\t                deferredEvents.push(e);\n\t                deferredClips.push(clip);\n\t            }\n\t        }\n\t\n\t        // Remove the finished clip\n\t        for (var i = 0; i < len;) {\n\t            if (clips[i]._needsRemove) {\n\t                clips[i] = clips[len - 1];\n\t                clips.pop();\n\t                len--;\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t\n\t        len = deferredEvents.length;\n\t        for (var i = 0; i < len; i++) {\n\t            deferredClips[i].fire(deferredEvents[i]);\n\t        }\n\t\n\t        this._time = time;\n\t\n\t        this.onframe(delta);\n\t\n\t        this.trigger('frame', delta);\n\t\n\t\t\t\n\t        if (this.stage.update) {\n\t            this.stage.update();\n\t        }\n\t\t\t\n\t    },\n\t\n\t    _startLoop: function () {\n\t        var self = this;\n\t\n\t        this._running = true;\n\t\n\t        function step() {\n\t            if (self._running) {\n\t\n\t                requestAnimationFrame(step);\n\t\n\t                !self._paused && self._update();\n\t            }\n\t        }\n\t\n\t        requestAnimationFrame(step);\n\t    },\n\t\n\t    /**\n\t     * \n\t     */\n\t    start: function () {\n\t\n\t        this._time = new Date().getTime();\n\t        this._pausedTime = 0;\n\t\n\t        this._startLoop();\n\t    },\n\t    /**\n\t     * \n\t     */\n\t    stop: function () {\n\t        this._running = false;\n\t    },\n\t\n\t    /**\n\t     * Pause\n\t     */\n\t    pause: function () {\n\t        if (!this._paused) {\n\t            this._pauseStart = new Date().getTime();\n\t            this._paused = true;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Resume\n\t     */\n\t    resume: function () {\n\t        if (this._paused) {\n\t            this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t            this._paused = false;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * \n\t     */\n\t    clear: function () {\n\t        this._clips = [];\n\t    },\n\t    /**\n\t     * animator\n\t     * @param  {Object} target\n\t     * @param  {Object} options\n\t     * @param  {boolean} [options.loop=false] \n\t     * @param  {Function} [options.getter=null]\n\t     *         gettergetter\n\t     * @param  {Function} [options.setter=null]\n\t     *         settersetter\n\t     * @return {module:zrender/animation/Animation~Animator}\n\t     */\n\t    // TODO Gap\n\t    animate: function (target, options) {\n\t        options = options || {};\n\t        var animator = new Animator(\n\t            target,\n\t            options.loop,\n\t            options.getter,\n\t            options.setter\n\t        );\n\t\n\t        return animator;\n\t    }\n\t};\n\t\n\tutil.mixin(Animation, Dispatcher);\n\t\n\tmodule.exports = Animation;\n\t\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/event\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(8);   \n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || true) {\n\t            defaultGetZrXY(el, e, out);\n\t        }       \n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * domtouch.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {    \n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t       \n\t        el.attachEvent('on' + name, handler);\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t      \n\t        el.detachEvent('on' + name, handler);\n\t\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // \n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t\n\tmodule.exports = function (func) {\n\t    setTimeout(func, 16);\n\t};\n\t\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Global defines\n\t\n\tvar guid = __webpack_require__(7);\n\tvar zrUtil = __webpack_require__(5);\n\tvar Handler = __webpack_require__(62);\n\tvar Storage = __webpack_require__(64);\n\tvar Animation = __webpack_require__(58);\n\tvar log = __webpack_require__(16);\n\t\n\tvar painterCtors = {\n\t    canvas: __webpack_require__(66)\n\t};\n\t\n\tvar instances = {};    // ZRendermap\n\t\n\tvar zrender = {};\n\t\n\t/**\n\t * @type {string}\n\t */\n\tzrender.version = 'WeZRender';\n\t\n\t/*** we\n\t * Initializing a zrender instance\n\t * @param {string} id\n\t * @param {number} width \n\t * @param {number} height\n\t * @return {module:zrender/ZRender}\n\t */\n\tzrender.init = function (id, width, height) {\n\t    var dom = {\n\t        id: id,\n\t        width: width,\n\t        height: height,\n\t        context: null,\n\t        getContext: function () {\n\t            if (!this.context) {\n\t                var ctx = wx.createCanvasContext(this.id);\n\t                ctx.id = this.id;\n\t\t\t\t\t\n\t                if (!ctx.setTransform) {\n\t                    ctx.setTransform = function () { }\n\t                }\n\t\t\t\t\t\n\t\t\t\t\tif (!ctx.setTransform) {\n\t\t\t\t\t\t ctx.measureText = {\n\t                    \n\t\t\t\t\t\t};\n\t\t\t\t\t}               \n\t\t\t\t\t\n\t                this.context = ctx;\n\t            }\n\t            return this.context;\n\t        }\n\t    };\n\t    var opts = {};\n\t    var zr = new ZRender(guid(), dom, opts);\n\t    instances[zr.id] = zr;\n\t    return zr;\n\t};\n\t/*** we ***/\n\t\n\t/**\n\t * Dispose zrender instance\n\t * @param {module:zrender/ZRender} zr\n\t */\n\tzrender.dispose = function (zr) {\n\t    if (zr) {\n\t        zr.dispose();\n\t    }\n\t    else {\n\t        for (var key in instances) {\n\t            if (instances.hasOwnProperty(key)) {\n\t                instances[key].dispose();\n\t            }\n\t        }\n\t        instances = {};\n\t    }\n\t\n\t    return zrender;\n\t};\n\t\n\t/**\n\t * Get zrender instance by id\n\t * @param {string} id zrender instance id\n\t * @return {module:zrender/ZRender}\n\t */\n\tzrender.getInstance = function (id) {\n\t    return instances[id];\n\t};\n\t\n\tzrender.registerPainter = function (name, Ctor) {\n\t    painterCtors[name] = Ctor;\n\t};\n\t\n\tfunction delInstance(id) {\n\t    delete instances[id];\n\t}\n\t\n\t/**\n\t * @module zrender/ZRender\n\t */\n\t/**\n\t * @constructor\n\t * @alias module:zrender/ZRender\n\t * @param {string} id\n\t * @param {Object} dom\n\t * @param {Object} opts\n\t */\n\tvar ZRender = function (id, dom, opts) {\n\t\n\t    opts = opts || {};\n\t\n\t    /**\n\t     * @type {Object}\n\t     */\n\t    this.dom = dom;\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    this.id = id;\n\t\n\t    var self = this;\n\t    var storage = new Storage();\n\t\n\t    var rendererType = 'canvas';\n\t\n\t    var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t    this.storage = storage;\n\t    this.painter = painter;\n\t\n\t    var handlerProxy = null;\n\t\n\t    this.handler = new Handler(storage, painter, handlerProxy, painter.root);\n\t\n\t    /**\n\t     * @type {module:zrender/animation/Animation}\n\t     */\n\t    this.animation = new Animation({\n\t        stage: {\n\t            update: zrUtil.bind(this.flush, this)\n\t        }\n\t    });\n\t    this.animation.start();\n\t\n\t    /**\n\t     * @type {boolean}\n\t     * @private\n\t     */\n\t    this._needsRefresh;\n\t\n\t    //  storage.delFromMap, \n\t    // FIXME ugly\n\t    var oldDelFromMap = storage.delFromMap;\n\t    var oldAddToMap = storage.addToMap;\n\t\n\t    storage.delFromMap = function (elId) {\n\t        var el = storage.get(elId);\n\t\n\t        oldDelFromMap.call(storage, elId);\n\t\n\t        el && el.removeSelfFromZr(self);\n\t    };\n\t\n\t    storage.addToMap = function (el) {\n\t        oldAddToMap.call(storage, el);\n\t\n\t        el.addSelfToZr(self);\n\t    };\n\t};\n\t\n\tZRender.prototype = {\n\t\n\t    constructor: ZRender,\n\t    /**\n\t     * \n\t     * @return {string}\n\t     */\n\t    getId: function () {\n\t        return this.id;\n\t    },\n\t\n\t    /**\n\t     * \n\t     * @param  {module:zrender/Element} el\n\t     */\n\t    add: function (el) {\n\t        this.storage.addRoot(el);\n\t        this._needsRefresh = true;\n\t    },\n\t\n\t    /**\n\t     * \n\t     * @param  {module:zrender/Element} el\n\t     */\n\t    remove: function (el) {\n\t        this.storage.delRoot(el);\n\t        this._needsRefresh = true;\n\t    },\n\t\n\t     /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t\n\t    /**\n\t     * Repaint the canvas immediately\n\t     */\n\t    refreshImmediately: function () {\n\t        // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t        // Or it will cause zrender refreshes again and again.\n\t        this._needsRefresh = false;\n\t        this.painter.refresh();\n\t        /**\n\t         * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t         */\n\t        this._needsRefresh = false;\n\t    },\n\t\n\t    /**\n\t     * Mark and repaint the canvas in the next frame of browser\n\t     */\n\t    refresh: function () {\n\t        this._needsRefresh = true;\n\t    },\n\t\n\t    /**\n\t     * Perform all refresh\n\t     */\n\t    flush: function () {\n\t        if (this._needsRefresh) {\n\t            this.refreshImmediately();\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * Stop and clear all animation immediately\n\t     */\n\t    clearAnimation: function () {\n\t        this.animation.clear();\n\t    },\n\t\n\t    /**\n\t     * Get container width\n\t     */\n\t    getWidth: function () {\n\t        return this.painter.getWidth();\n\t    },\n\t\n\t    /**\n\t     * Get container height\n\t     */\n\t    getHeight: function () {\n\t        return this.painter.getHeight();\n\t    },\n\t\n\t    /**\n\t     * Bind event\n\t     *\n\t     * @param {string} eventName Event name\n\t     * @param {Function} eventHandler Handler function\n\t     * @param {Object} [context] Context object\n\t     */\n\t    on: function (eventName, eventHandler, context) {\n\t        this.handler.on(eventName, eventHandler, context);\n\t    },\n\t\n\t    /**\n\t     * Unbind event\n\t     * @param {string} eventName Event name\n\t     * @param {Function} [eventHandler] Handler function\n\t     */\n\t    off: function (eventName, eventHandler) {\n\t        this.handler.off(eventName, eventHandler);\n\t    },\n\t\n\t    /**\n\t     * Trigger event manually\n\t     *\n\t     * @param {string} eventName Event name\n\t     * @param {event=} event Event object\n\t     */\n\t    trigger: function (eventName, event) {\n\t        this.handler.trigger(eventName, event);\n\t    },\n\t\n\t\n\t    /**\n\t     * Clear all objects and the canvas.\n\t     */\n\t    clear: function () {\n\t        this.storage.delRoot();\n\t        this.painter.clear();\n\t    },\n\t\n\t    /**\n\t     * Dispose self.\n\t     */\n\t    dispose: function () {\n\t        this.animation.stop();\n\t\n\t        this.clear();\n\t        this.storage.dispose();\n\t        this.painter.dispose();\n\t        this.handler.dispose();\n\t\n\t        this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t        delInstance(this.id);\n\t    }\n\t};\n\t\n\tmodule.exports = zrender;\n\t\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(5);\n\t    var Draggable = __webpack_require__(63);\n\t\n\t    var Eventful = __webpack_require__(8);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t      \n\t        /**\n\t         * \n\t         *\n\t         * @private\n\t         * @param {Object} targetEl \n\t         * @param {string} eventName \n\t         * @param {Object} event \n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(5);\n\tvar Group = __webpack_require__(4);\n\t\n\t// Use timsort because in most case elements are partially sorted\n\t// https://jsfiddle.net/pissang/jr4x7mdm/8/\n\tvar timsort = __webpack_require__(65);\n\t\n\tfunction shapeCompareFunc(a, b) {\n\t    if (a.zlevel === b.zlevel) {\n\t        if (a.z === b.z) {\n\t            // if (a.z2 === b.z2) {\n\t            //     // FIXME Slow has renderidx compare\n\t            //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t            //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t            //     return a.__renderidx - b.__renderidx;\n\t            // }\n\t            return a.z2 - b.z2;\n\t        }\n\t        return a.z - b.z;\n\t    }\n\t    return a.zlevel - b.zlevel;\n\t}\n\t/**\n\t *  (M)\n\t * @alias module:zrender/Storage\n\t * @constructor\n\t */\n\tvar Storage = function () {\n\t    // idmap\n\t    this._elements = {};\n\t\n\t    this._roots = [];\n\t\n\t    this._displayList = [];\n\t\n\t    this._displayListLen = 0;\n\t};\n\t\n\tStorage.prototype = {\n\t\n\t    constructor: Storage,\n\t\n\t    /**\n\t     * @param  {Function} cb\n\t     *\n\t     */\n\t    traverse: function (cb, context) {\n\t        for (var i = 0; i < this._roots.length; i++) {\n\t            this._roots[i].traverse(cb, context);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * \n\t     * @param {boolean} [update=false] \n\t     * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n\t     *\n\t     * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t     * @return {Array.<module:zrender/graphic/Displayable>}\n\t     */\n\t    getDisplayList: function (update, includeIgnore) {\n\t        includeIgnore = includeIgnore || false;\n\t        if (update) {\n\t            this.updateDisplayList(includeIgnore);\n\t        }\n\t        return this._displayList;\n\t    },\n\t\n\t    /**\n\t     * \n\t     * GroupShapeShape\n\t     * zlevel > z > \n\t     * @param {boolean} [includeIgnore=false]  ignore \n\t     */\n\t    updateDisplayList: function (includeIgnore) {\n\t        this._displayListLen = 0;\n\t        var roots = this._roots;\n\t        var displayList = this._displayList;\n\t        for (var i = 0, len = roots.length; i < len; i++) {\n\t            this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t        }\n\t        displayList.length = this._displayListLen;\n\t\n\t        // for (var i = 0, len = displayList.length; i < len; i++) {\n\t        //     displayList[i].__renderidx = i;\n\t        // }\n\t\n\t        // displayList.sort(shapeCompareFunc);\n\t        false && timsort(displayList, shapeCompareFunc);\n\t    },\n\t\n\t    _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t        if (el.ignore && !includeIgnore) {\n\t            return;\n\t        }\n\t\n\t        el.beforeUpdate();\n\t\n\t        if (el.__dirty) {\n\t\n\t            el.update();\n\t\n\t        }\n\t\n\t        el.afterUpdate();\n\t\n\t        /*** we\n\t        var clipPath = el.clipPath;\n\t        if (clipPath) {\n\t            // clipPath  group \n\t            clipPath.parent = el;\n\t            clipPath.updateTransform();\n\t\n\t            // FIXME \n\t            if (clipPaths) {\n\t                clipPaths = clipPaths.slice();\n\t                clipPaths.push(clipPath);\n\t            }\n\t            else {\n\t                clipPaths = [clipPath];\n\t            }\n\t        }\n\t        we ***/\n\t\n\t        /*** we ***/\n\t        var userSetClipPath = el.clipPath;\n\t        if (userSetClipPath) {\n\t\n\t            // FIXME \n\t            if (clipPaths) {\n\t                clipPaths = clipPaths.slice();\n\t            }\n\t            else {\n\t                clipPaths = [];\n\t            }\n\t\n\t            var currentClipPath = userSetClipPath;\n\t            var parentClipPath = el;\n\t            // Recursively add clip path\n\t            while (currentClipPath) {\n\t                // clipPath  clipPath \n\t                currentClipPath.parent = parentClipPath;\n\t                currentClipPath.updateTransform();\n\t\n\t                clipPaths.push(currentClipPath);\n\t\n\t                parentClipPath = currentClipPath;\n\t                currentClipPath = currentClipPath.clipPath;\n\t            }\n\t        }\n\t        /*** we ***/\n\t\n\t        if (el.isGroup) {\n\t            var children = el._children;\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t\n\t                // Force to mark as dirty if group is dirty\n\t                // FIXME __dirtyPath ?\n\t                if (el.__dirty) {\n\t                    child.__dirty = true;\n\t                }\n\t\n\t                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t            }\n\t\n\t            // Mark group clean here\n\t            el.__dirty = false;\n\t\n\t        }\n\t        else {\n\t            el.__clipPaths = clipPaths;\n\t\n\t            this._displayList[this._displayListLen++] = el;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * (Shape)(Group)\n\t     * @param {module:zrender/Element} el\n\t     */\n\t    addRoot: function (el) {\n\t        // Element has been added\n\t        if (this._elements[el.id]) {\n\t            return;\n\t        }\n\t\n\t        if (el instanceof Group) {\n\t            el.addChildrenToStorage(this);\n\t        }\n\t\n\t        this.addToMap(el);\n\t        this._roots.push(el);\n\t    },\n\t\n\t    /**\n\t     * (Shape)(Group)\n\t     * @param {string|Array.<string>} [elId] Storage\n\t     */\n\t    delRoot: function (elId) {\n\t        if (elId == null) {\n\t            // elId\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                var root = this._roots[i];\n\t                if (root instanceof Group) {\n\t                    root.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t\n\t            this._elements = {};\n\t            this._roots = [];\n\t            this._displayList = [];\n\t            this._displayListLen = 0;\n\t\n\t            return;\n\t        }\n\t\n\t        if (elId instanceof Array) {\n\t            for (var i = 0, l = elId.length; i < l; i++) {\n\t                this.delRoot(elId[i]);\n\t            }\n\t            return;\n\t        }\n\t\n\t        var el;\n\t        if (typeof (elId) == 'string') {\n\t            el = this._elements[elId];\n\t        }\n\t        else {\n\t            el = elId;\n\t        }\n\t\n\t        var idx = util.indexOf(this._roots, el);\n\t        if (idx >= 0) {\n\t            this.delFromMap(el.id);\n\t            this._roots.splice(idx, 1);\n\t            if (el instanceof Group) {\n\t                el.delChildrenFromStorage(this);\n\t            }\n\t        }\n\t    },\n\t\n\t    addToMap: function (el) {\n\t        if (el instanceof Group) {\n\t            el.__storage = this;\n\t        }\n\t        el.dirty(false);\n\t\n\t        this._elements[el.id] = el;\n\t\n\t        return this;\n\t    },\n\t\n\t    get: function (elId) {\n\t        return this._elements[elId];\n\t    },\n\t\n\t    delFromMap: function (elId) {\n\t        var elements = this._elements;\n\t        var el = elements[elId];\n\t        if (el) {\n\t            delete elements[elId];\n\t            if (el instanceof Group) {\n\t                el.__storage = null;\n\t            }\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Storage\n\t     */\n\t    dispose: function () {\n\t        this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t    },\n\t\n\t    displayableSortFunc: shapeCompareFunc\n\t};\n\t\n\tmodule.exports = Storage;\n\t\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar config = __webpack_require__(17);\n\tvar util = __webpack_require__(5);\n\tvar log = __webpack_require__(16);\n\tvar BoundingRect = __webpack_require__(18);\n\tvar timsort = __webpack_require__(65);\n\tvar Layer = __webpack_require__(67);\n\t\n\tfunction parseInt10(val) {\n\t    return parseInt(val, 10);\n\t}\n\t\n\tvar tmpRect = new BoundingRect(0, 0, 0, 0);\n\tvar viewRect = new BoundingRect(0, 0, 0, 0);\n\t\n\tfunction isDisplayableCulled(el, width, height) {\n\t    tmpRect.copy(el.getBoundingRect());\n\t    if (el.transform) {\n\t        tmpRect.applyTransform(el.transform);\n\t    }\n\t    viewRect.width = width;\n\t    viewRect.height = height;\n\t    return !tmpRect.intersect(viewRect);\n\t}\n\t\n\tfunction isClipPathChanged(clipPaths, prevClipPaths) {\n\t    if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t        return false;\n\t    }\n\t\n\t    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t        return true;\n\t    }\n\t    for (var i = 0; i < clipPaths.length; i++) {\n\t        if (clipPaths[i] !== prevClipPaths[i]) {\n\t            return true;\n\t        }\n\t    }\n\t}\n\t\n\tfunction doClip(clipPaths, ctx) {\n\t\t/*** we\n\t    for (var i = 0; i < clipPaths.length; i++) {\n\t        var clipPath = clipPaths[i];\n\t        var path = clipPath.path;\n\t\n\t        clipPath.setTransform(ctx);\n\t        path.beginPath(ctx);\n\t        clipPath.buildPath(path, clipPath.shape);\n\t        ctx.clip();\n\t        // Transform back\n\t        clipPath.restoreTransform(ctx);\n\t    }\n\t\twe ***/\n\t}\n\t\n\t/**\n\t * @alias module:zrender/Painter\n\t * @constructor\n\t * @param {Object} root \n\t * @param {module:zrender/Storage} storage\n\t * @param {Ojbect} opts\n\t */\n\tvar Painter = function (root, storage, opts) {\n\t\n\t\n\t    this._opts = opts = util.extend({}, opts || {});\n\t\n\t    /**\n\t     * @type {number}\n\t     */\n\t    this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t\n\t    /**\n\t     * \n\t     * @type {Object}\n\t     */\n\t    this.root = root;\n\t\n\t    /**\n\t     * @type {module:zrender/Storage}\n\t     */\n\t    this.storage = storage;\n\t\n\t    /**\n\t     * @type {Array.<number>}\n\t     * @private\n\t     */\n\t    var zlevelList = this._zlevelList = [];\n\t\n\t    /**\n\t     * @type {Object.<string, module:zrender/Layer>}\n\t     * @private\n\t     */\n\t    var layers = this._layers = {};\n\t\n\t    /**\n\t     * @type {Object.<string, Object>}\n\t     * @type {private}\n\t     */\n\t    this._layerConfig = {};\n\t\n\t\n\t    // Use canvas width and height directly\n\t    var width = root.width;\n\t    var height = root.height;\n\t    this._width = width;\n\t    this._height = height;\n\t\n\t    // Create layer if only one given canvas\n\t    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t    var mainLayer = new Layer(root, this, 1);\n\t    mainLayer.initContext();\n\t    // FIXME Use canvas width and height\n\t    // mainLayer.resize(width, height);\n\t    layers[0] = mainLayer;\n\t    zlevelList.push(0);\n\t\n\t};\n\t\n\tPainter.prototype = {\n\t\n\t    constructor: Painter,\n\t\n\t    /**\n\t     * @return {HTMLDivElement}\n\t     */\n\t    getViewportRoot: function () {\n\t        return this._layers[0].dom;\n\t    },\n\t\n\t    /**\n\t     * \n\t     * @param {boolean} [paintAll=false] displayable\n\t     */\n\t    refresh: function (paintAll) {\n\t\t\t\n\t        var list = this.storage.getDisplayList(true);\t\n\t\t\t\n\t        this._paintList(list, paintAll);       \n\t\n\t        return this;\n\t    },\n\t\n\t\n\t    _paintList: function (list, paintAll) {\n\t\n\t        if (paintAll == null) {\n\t            paintAll = false;\n\t        }\n\t\n\t        this._doPaintList(list, paintAll);\n\t    },\n\t\n\t    _doPaintList: function (list, paintAll) {\n\t\t\t\n\t        var currentLayer;\n\t        var currentZLevel;\n\t        var ctx;\n\t\n\t        // var invTransform = [];\n\t        var scope;\n\t\n\t        var width = this._width;\n\t        var height = this._height;\n\t\n\t        for (var i = 0, l = list.length; i < l; i++) {\n\t            var el = list[i];\n\t            var elZLevel = 0;\n\t\n\t            var elFrame = el.__frame;\n\t\n\t            // Change draw layer\n\t            if (currentZLevel !== elZLevel) {\n\t                if (ctx) {\n\t                    ctx.restore();\n\t                }\n\t\n\t                // Reset scope\n\t                scope = {};\n\t\n\t                // Only 0 zlevel if only has one canvas\n\t                currentZLevel = elZLevel;\n\t                currentLayer = this.getLayer(currentZLevel);\n\t\n\t                ctx = currentLayer.ctx;\n\t                ctx.save();\n\t\n\t                // Reset the count\n\t                currentLayer.__unusedCount = 0;\n\t\n\t                if (currentLayer.__dirty || paintAll) {\n\t                    currentLayer.clear();\n\t                }\n\t            }\n\t\n\t            if (!(currentLayer.__dirty || paintAll)) {\n\t                continue;\n\t            }\n\t\n\t            if (elFrame >= 0) {\n\t\n\t            }\n\t            else {\n\t                this._doPaintEl(el, currentLayer, paintAll, scope);\n\t            }\n\t\n\t            el.__dirty = false;\n\t        }\n\t\n\t        // Restore the lastLayer ctx\n\t        ctx && ctx.restore();\n\t        // If still has clipping state\n\t        // if (scope.prevElClipPaths) {\n\t        //     ctx.restore();\n\t        // }        \n\t    },\n\t\n\t    _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t\t\t\n\t        var ctx = currentLayer.ctx;\n\t        var m = el.transform;\n\t        if (\n\t            (currentLayer.__dirty || forcePaint)\n\t            // Ignore invisible element\n\t            && !el.invisible\n\t            // Ignore transparent element\n\t            && el.style.opacity !== 0\n\t            // Ignore scale 0 element, in some environment like node-canvas\n\t            // Draw a scale 0 element can cause all following draw wrong\n\t            // And setTransform with scale 0 will cause set back transform failed.\n\t            && !(m && !m[0] && !m[3])\n\t            // Ignore culled element\n\t            && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t        ) {\n\t\n\t            var clipPaths = el.__clipPaths;\n\t\n\t            // Optimize when clipping on group with several elements\n\t            if (scope.prevClipLayer !== currentLayer\n\t                || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t            ) {\n\t                // If has previous clipping state, restore from it\n\t                if (scope.prevElClipPaths) {\n\t                    scope.prevClipLayer.ctx.restore();\n\t                    scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                    // Reset prevEl since context has been restored\n\t                    scope.prevEl = null;\n\t                }\n\t                // New clipping state\n\t                if (clipPaths) {\n\t                    ctx.save();\n\t                    doClip(clipPaths, ctx);\n\t                    scope.prevClipLayer = currentLayer;\n\t                    scope.prevElClipPaths = clipPaths;\n\t                }\n\t            }\n\t            el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t            el.brush(ctx, scope.prevEl || null);\n\t            scope.prevEl = el;\n\t\n\t\t\t\t\n\t            /*** we ***/\n\t            ctx.draw(true);\n\t            /*** we ***/\n\t\n\t            el.afterBrush && el.afterBrush(ctx);\n\t        }\n\t    },\n\t\n\t    /**\n\t     *  zlevel \n\t     * @param {number} zlevel\n\t     * @return {module:zrender/Layer}\n\t     */\n\t    getLayer: function (zlevel) {\n\t        return this._layers[0];\n\t    },\n\t\n\t    // Iterate each layer\n\t    eachLayer: function (cb, context) {\n\t        var zlevelList = this._zlevelList;\n\t        var z;\n\t        var i;\n\t        for (i = 0; i < zlevelList.length; i++) {\n\t            z = zlevelList[i];\n\t            cb.call(context, this._layers[z], z);\n\t        }\n\t    },\n\t\n\t    // Iterate each buildin layer\n\t    eachBuildinLayer: function (cb, context) {\n\t        var zlevelList = this._zlevelList;\n\t        var layer;\n\t        var z;\n\t        var i;\n\t        for (i = 0; i < zlevelList.length; i++) {\n\t            z = zlevelList[i];\n\t            layer = this._layers[z];\n\t            if (layer.isBuildin) {\n\t                cb.call(context, layer, z);\n\t            }\n\t        }\n\t    },\n\t\n\t    // Iterate each other layer except buildin layer\n\t    eachOtherLayer: function (cb, context) {\n\t        var zlevelList = this._zlevelList;\n\t        var layer;\n\t        var z;\n\t        var i;\n\t        for (i = 0; i < zlevelList.length; i++) {\n\t            z = zlevelList[i];\n\t            layer = this._layers[z];\n\t            if (!layer.isBuildin) {\n\t                cb.call(context, layer, z);\n\t            }\n\t        }\n\t    },\n\t\n\t    /**\n\t     * \n\t     * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t     */\n\t    getLayers: function () {\n\t        return this._layers;\n\t    },\n\t\n\t    /**\n\t     * hover\n\t     */\n\t    clear: function () {\n\t        this.eachBuildinLayer(this._clearLayer);\n\t        return this;\n\t    },\n\t\n\t    _clearLayer: function (layer) {\n\t        layer.clear();\n\t    },\n\t\n\t /**\n\t         * zlevel\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config \n\t         * @param {string} [config.clearColor=0] \n\t         * @param {string} [config.motionBlur=false] \n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 alpha\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t    /**\n\t     * \n\t     */\n\t    dispose: function () {\n\t        this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t    },\n\t\n\t\n\t    /**\n\t     * \n\t     */\n\t    getWidth: function () {\n\t        return this._width;\n\t    },\n\t\n\t    /**\n\t     * \n\t     */\n\t    getHeight: function () {\n\t        return this._height;\n\t    }\n\t};\n\t\n\tmodule.exports = Painter;\n\t\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(5);\n\tvar config = __webpack_require__(17);\n\tvar Style = __webpack_require__(22);\n\tvar Pattern = __webpack_require__(33);\n\tvar log = __webpack_require__(16);\n\t\n\t/**\n\t * @alias module:zrender/Layer\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @param {Object} dom\n\t * @param {module:zrender/Painter} painter\n\t * @param {number} [dpr]\n\t */\n\tvar Layer = function (dom, painter, dpr) {\n\t\n\t    this.id = dom.id;\n\t    this.dom = dom;\n\t\n\t    this.ctxBack = null;\n\t\n\t    this.painter = painter;\n\t\n\t    this.config = null;\n\t\n\t    // Configs\n\t    /**\n\t     * \n\t     * @type {string}\n\t     * @default 0\n\t     */\n\t    this.clearColor = 0;\n\t    /**\n\t     * \n\t     * @type {boolean}\n\t     * @default false\n\t     */\n\t    this.motionBlur = false;\n\t    /**\n\t     * alpha\n\t     * @type {number}\n\t     * @default 0.7\n\t     */\n\t    this.lastFrameAlpha = 0.7;\n\t\n\t    /**\n\t     * Layer dpr\n\t     * @type {number}\n\t     */\n\t    this.dpr = dpr;\n\t};\n\t\n\tLayer.prototype = {\n\t\n\t    constructor: Layer,\n\t\n\t    elCount: 0,\n\t\n\t    __dirty: true,\n\t\n\t    initContext: function () {\n\t        this.ctx = this.dom.getContext('2d');\n\t\n\t        this.ctx.dpr = this.dpr;\n\t    },\n\t    \n\t    /**\n\t     * \n\t     * @param {boolean} clearAll Clear all with out motion blur\n\t     */\n\t    clear: function (clearAll) {\n\t        var dom = this.dom;\n\t        var ctx = this.ctx;\n\t        var width = dom.width;\n\t        var height = dom.height;\n\t\n\t        var clearColor = this.clearColor;\n\t\n\t        var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t        var dpr = this.dpr;\n\t\n\t        ctx.clearRect(0, 0, width, height);\n\t        if (clearColor) {\n\t            var clearColorGradientOrPattern;\n\t            // Gradient\n\t            if (clearColor.colorStops) {\n\t                // Cache canvas gradient\n\t                clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                    x: 0,\n\t                    y: 0,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t\n\t                clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t            }\n\t            // Pattern\n\t            else if (clearColor.image) {\n\t                clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t            }\n\t            ctx.save();\n\t            ctx.setFillStyle(clearColorGradientOrPattern || clearColor);\n\t            ctx.fillRect(0, 0, width, height);\n\t            ctx.restore();\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = Layer;\n\n\n/***/ }\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// wezrender.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6c9a1e78787ba227f9da","\r\nvar core = {\r\n\tbbox             :     require('./core/bbox'),\r\n};\r\n\r\nvar container = {\r\n\tGroup            :     require('./container/Group'),\r\n}\r\n\r\nvar shape = {\r\n    Arc             :     require('./graphic/shape/Arc'),\r\n    BezierCurve     :     require('./graphic/shape/BezierCurve'),\r\n    Circle          :     require('./graphic/shape/Circle'),\r\n    Droplet         :     require('./graphic/shape/Droplet'),\r\n    Ellipse         :     require('./graphic/shape/Ellipse'),\r\n    Heart           :     require('./graphic/shape/Heart'),\r\n    Isogon          :     require('./graphic/shape/Isogon'),\r\n    Line            :     require('./graphic/shape/Line'),    \r\n    Polyline        :     require('./graphic/shape/Polyline'),\r\n    Polygon         :     require('./graphic/shape/Polygon'),\r\n    Rect            :     require('./graphic/shape/Rect'),\r\n    Ring            :     require('./graphic/shape/Ring'),\r\n    Rose            :     require('./graphic/shape/Rose'),\r\n    Sector          :     require('./graphic/shape/Sector'),\r\n    Star            :     require('./graphic/shape/Star'),\r\n    Trochoid        :     require('./graphic/shape/Trochoid')\r\n};\r\n\r\n\r\n\r\nvar graphic = {\r\n\t\r\n    shape           :     shape,\r\n\r\n    Path        \t:     require('./graphic/Path'),    \r\n\r\n    Gradient        :     require('./graphic/Gradient'),    \r\n    LinearGradient  :     require('./graphic/LinearGradient'),   \r\n    RadialGradient  :     require('./graphic/RadialGradient'),   \r\n\r\n    Text            :     require('./graphic/Text'),\r\n\tImage           :     require('./graphic/Image'),\r\n}\r\n\r\nvar animation = {\r\n    Animation       :     require('./animation/Animation'),    \r\n}\r\n\r\nmodule.exports = {\r\n    zrender         :     require('./zrender'),\r\n\t\r\n\tcore\t\t\t:     core,\r\n\tcontainer\t\t:     container,\r\n\r\n    graphic         :     graphic\r\n    \r\n    \r\n \r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0 1","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/bbox.js\n// module id = 1\n// module chunks = 0 1","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/vector.js\n// module id = 2\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/curve.js\n// module id = 3\n// module chunks = 0 1","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/container/Group.js\n// module id = 4\n// module chunks = 0 1","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n   \n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n      \n    \n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/util.js\n// module id = 5\n// module chunks = 0 1","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\t\t\t\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Element.js\n// module id = 6\n// module chunks = 0 1","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/guid.js\n// module id = 7\n// module chunks = 0 1","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/mixin/Eventful.js\n// module id = 8\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/mixin/Transformable.js\n// module id = 9\n// module chunks = 0 1","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/matrix.js\n// module id = 10\n// module chunks = 0 1","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\t\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\t\t\t\n\t\t\t\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/mixin/Animatable.js\n// module id = 11\n// module chunks = 0 1","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n\t\t\t\n\t\t\t\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\t\t\t\n\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\t\t\t\n\t\t\t\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n\t\t\t\n\t\t\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/animation/Animator.js\n// module id = 12\n// module chunks = 0 1","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t\t\t\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n\t\t\t\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\t\t\t\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n\t\t\t\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\t\n                this[eventType](this._target, arg);\n            }\n\t\t\t\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/animation/Clip.js\n// module id = 13\n// module chunks = 0 1","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/animation/easing.js\n// module id = 14\n// module chunks = 0 1","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tool/color.js\n// module id = 15\n// module chunks = 0 1","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        \n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/log.js\n// module id = 16\n// module chunks = 0 1","\n    var dpr = 1;\n    \n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 2,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/config.js\n// module id = 17\n// module chunks = 0 1","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/BoundingRect.js\n// module id = 18\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'arc',\n\n    shape: {\n\n        cx: 0,\n\n        cy: 0,\n\n        r: 0,\n\n        startAngle: 0,\n\n        endAngle: Math.PI * 2,\n\n        clockwise: true\n    },\n\n    style: {\n\n        stroke: '#000000',\n\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n\n        var x = shape.cx;\n        var y = shape.cy;\n        var r = Math.max(shape.r, 0);\n        var startAngle = shape.startAngle;\n        var endAngle = shape.endAngle;\n        var clockwise = shape.clockwise;\n\n        var unitX = Math.cos(startAngle);\n        var unitY = Math.sin(startAngle);\n\n        ctx.moveTo(unitX * r + x, unitY * r + y);\n        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Arc.js\n// module id = 19\n// module chunks = 0 1","/**\n * Path element\n * @module zrender/graphic/Path\n */\n var log = require('../core/log');\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\t\t\t\t\t\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.setFillStyle(this._fillGradient);\n            }\n            else if (hasFillPattern) {\n                ctx.setFillStyle(getCanvasPattern.call(fill, ctx));\n            }\n            if (hasStrokeGradient) {\n                ctx.setStrokeStyle(this._strokeGradient);\n            }\n            else if (hasStrokePattern) {\n                ctx.setStrokeStyle(getCanvasPattern.call(stroke, ctx));\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\t\t\t\n\t\t\t/*** we ***/\n\t\t\tvar lineWidth = style.lineWidth;\n\t\t\tif (hasStroke) {\n\t\t\t\tctx.setLineWidth(lineWidth);\n\t\t\t}\t\t\t\t\n\t\t\t\n\t\t\tvar shadowBlur = style.shadowBlur;\n\t\t\tvar shadowOffsetX = style.shadowOffsetX || 0;\n\t\t\tvar shadowOffsetY = style.shadowOffsetY || 0;\n\t\t\tvar shadowColor = style.shadowColor || '#000000';\n\t\t\t\n\t\t\tif (shadowBlur) {\n\t\t\t\tctx.setShadow(shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor);\n\t\t\t}\n\t\t\t\n\t\t\tvar lineCap = style.lineCap;\n\t\t\t\n\t\t\tif (lineCap) {\n\t\t\t\tctx.setLineCap(lineCap);\n\t\t\t}\n\t\t\t\n\t\t\tvar lineJoin = style.lineJoin;\n\t\t\t\n\t\t\tif (lineJoin) {\n\t\t\t\tctx.setLineJoin(lineJoin);\n\t\t\t}\n\t\t\t\n\t\t\tvar miterLimit = style.miterLimit;\n\t\t\t\n\t\t\tif (miterLimit) {\n\t\t\t\tctx.setMiterLimit(miterLimit);\n\t\t\t}\n\n\t\t\t/*** we ***/\n            \n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Path.js\n// module id = 20\n// module chunks = 0 1","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Displayable.js\n// module id = 21\n// module chunks = 0 1","/**\n * @module zrender/graphic/Style\n */\n\n var log = require('../core/log');\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\t\t\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n         textFill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            } \n            if ((firstDraw || style.fill !== prevStyle.fill)) {                \n                ctx.setFillStyle(style.fill);\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.setStrokeStyle(style.stroke);\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.setGlobalAlpha(style.opacity == null ? 1 : style.opacity);\n            }\n  \n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\t\t\t\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n\t\t\t\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\t\n\t\t\t\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Style.js\n// module id = 22\n// module chunks = 0 1","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\tvar log = require('../../core/log');\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\t\t\t\n            var style = this.style;\n\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\t\n\n\t\t\t\t\t\t\n            // Transform rect to view space\n\t\t\t\n            var transform = this.transform;\n\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\t\t\t\t\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n\t\t\t\t\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\t\t\t\n\t\t\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.setFillStyle(textFill));\n            textStroke && (ctx.setStrokeStyle(textStroke));\n\n\t\t\t\n            // TODO Invalid font\n\t\t\tvar fontSize = parseInt(\n\t\t\t\t(font || '18 simsun').split(' ')[0].replace('px', ''));\n            ctx.setFontSize(fontSize);\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t\t\t\n\t\t\t/*** we ***/\n\t\t\tctx.setShadow(style.textShadowOffsetX, style.textShadowOffsetY, style.textShadowBlur, style.textShadowColor || 'rgba(0, 0, 0, 1)');\n            /*** we ***/\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\t\n\t\t\t\n\t\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/mixin/RectText.js\n// module id = 23\n// module chunks = 0 1","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\t\tvar fontSize = parseInt(\n\t\t\t(textFont || '18 simsun').split(' ')[0].replace('px', ''));\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], fontSize).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, fontSize) {\n           /*** we ***/\n\t\t   // MeasureText always return a fixed value   \n\t\t   return { width: 18}\n\t\t   /*** we ***/\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/text.js\n// module id = 24\n// module chunks = 0 1","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/PathProxy.js\n// module id = 25\n// module chunks = 0 1","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/path.js\n// module id = 26\n// module chunks = 0 1","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/line.js\n// module id = 27\n// module chunks = 0 1","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/cubic.js\n// module id = 28\n// module chunks = 0 1","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/quadratic.js\n// module id = 29\n// module chunks = 0 1","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/arc.js\n// module id = 30\n// module chunks = 0 1","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/util.js\n// module id = 31\n// module chunks = 0 1","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/contain/windingLine.js\n// module id = 32\n// module chunks = 0 1","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Pattern.js\n// module id = 33\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\nvar curveTool = require('../../core/curve');\nvar vec2 = require('../../core/vector');\nvar quadraticSubdivide = curveTool.quadraticSubdivide;\nvar cubicSubdivide = curveTool.cubicSubdivide;\nvar quadraticAt = curveTool.quadraticAt;\nvar cubicAt = curveTool.cubicAt;\nvar quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\nvar cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    if (cpx2 === null || cpy2 === null) {\n        return [\n            (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n            (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n        ];\n    }\n    else {\n        return [\n            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n        ];\n    }\n}\nmodule.exports = require('../Path').extend({\n\n    type: 'bezier-curve',\n\n    shape: {\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: 0,\n        cpx1: 0,\n        cpy1: 0,\n        // cpx2: 0,\n        // cpy2: 0\n\n        // Curve show percent, for animating\n        percent: 1\n    },\n\n    style: {\n        stroke: '#000000',\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        var x1 = shape.x1;\n        var y1 = shape.y1;\n        var x2 = shape.x2;\n        var y2 = shape.y2;\n        var cpx1 = shape.cpx1;\n        var cpy1 = shape.cpy1;\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        var percent = shape.percent;\n        if (percent === 0) {\n            return;\n        }\n\n        ctx.moveTo(x1, y1);\n\n        if (cpx2 == null || cpy2 == null) {\n            if (percent < 1) {\n                quadraticSubdivide(\n                    x1, cpx1, x2, percent, out\n                );\n                cpx1 = out[1];\n                x2 = out[2];\n                quadraticSubdivide(\n                    y1, cpy1, y2, percent, out\n                );\n                cpy1 = out[1];\n                y2 = out[2];\n            }\n\n            ctx.quadraticCurveTo(\n                cpx1, cpy1,\n                x2, y2\n            );\n        }\n        else {\n            if (percent < 1) {\n                cubicSubdivide(\n                    x1, cpx1, cpx2, x2, percent, out\n                );\n                cpx1 = out[1];\n                cpx2 = out[2];\n                x2 = out[3];\n                cubicSubdivide(\n                    y1, cpy1, cpy2, y2, percent, out\n                );\n                cpy1 = out[1];\n                cpy2 = out[2];\n                y2 = out[3];\n            }\n            ctx.bezierCurveTo(\n                cpx1, cpy1,\n                cpx2, cpy2,\n                x2, y2\n            );\n        }\n    },\n\n    /**\n     * Get point at percent\n     * @param  {number} t\n     * @return {Array.<number>}\n     */\n    pointAt: function (t) {\n        return someVectorAt(this.shape, t, false);\n    },\n\n    /**\n     * Get tangent at percent\n     * @param  {number} t\n     * @return {Array.<number>}\n     */\n    tangentAt: function (t) {\n        var p = someVectorAt(this.shape, t, true);\n        return vec2.normalize(p, p);\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/BezierCurve.js\n// module id = 34\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'circle',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        r: 0\n    },\n\n\n    buildPath: function (ctx, shape, inBundle) {\n        // Better stroking in ShapeBundle\n        // Always do it may have performence issue ( fill may be 2x more cost)\n        if (inBundle) {\n            ctx.moveTo(shape.cx + shape.r, shape.cy);\n        }\n        // Better stroking in ShapeBundle\n        // ctx.moveTo(shape.cx + shape.r, shape.cy);\n        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Circle.js\n// module id = 35\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/graphic/shape/Droplet\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'droplet',\n\n    shape: {\n        cx: 0, cy: 0,\n        width: 0, height: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var x = shape.cx;\n        var y = shape.cy;\n        var a = shape.width;\n        var b = shape.height;\n\n        ctx.moveTo(x, y + a);\n        ctx.bezierCurveTo(\n            x + a,\n            y + a,\n            x + a * 3 / 2,\n            y - a / 3,\n            x,\n            y - b\n        );\n        ctx.bezierCurveTo(\n            x - a * 3 / 2,\n            y - a / 3,\n            x - a,\n            y + a,\n            x,\n            y + a\n        );\n        ctx.closePath();\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Droplet.js\n// module id = 36\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/graphic/shape/Ellipse\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'ellipse',\n\n    shape: {\n        cx: 0, cy: 0,\n        rx: 0, ry: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var k = 0.5522848;\n        var x = shape.cx;\n        var y = shape.cy;\n        var a = shape.rx;\n        var b = shape.ry;\n        var ox = a * k; // \n        var oy = b * k; // \n        // \n        ctx.moveTo(x - a, y);\n        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\n        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\n        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\n        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\n        ctx.closePath();\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Ellipse.js\n// module id = 37\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/graphic/shape/Heart\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'heart',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        width: 0,\n        height: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var x = shape.cx;\n        var y = shape.cy;\n        var a = shape.width;\n        var b = shape.height;\n        ctx.moveTo(x, y);\n        ctx.bezierCurveTo(\n            x + a / 2, y - b * 2 / 3,\n            x + a * 2, y + b / 3,\n            x, y + b\n        );\n        ctx.bezierCurveTo(\n            x - a * 2, y + b / 3,\n            x - a / 2, y - b * 2 / 3,\n            x, y\n        );\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Heart.js\n// module id = 38\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/shape/Isogon\n * @author sushuang (, sushuang0322@gmail.com)\n */\n\nvar PI = Math.PI;\nvar sin = Math.sin;\nvar cos = Math.cos;\n\nmodule.exports = require('../Path').extend({\n\n    type: 'isogon',\n\n    shape: {\n        x: 0, y: 0,\n        r: 0, n: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var n = shape.n;\n        if (!n || n < 2) {\n            return;\n        }\n\n        var x = shape.x;\n        var y = shape.y;\n        var r = shape.r;\n\n        var dStep = 2 * PI / n;\n        var deg = -PI / 2;\n\n        ctx.moveTo(x + r * cos(deg), y + r * sin(deg));\n        for (var i = 0, end = n - 1; i < end; i++) {\n            deg += dStep;\n            ctx.lineTo(x + r * cos(deg), y + r * sin(deg));\n        }\n\n        ctx.closePath();\n\n        return;\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Isogon.js\n// module id = 39\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'line',\n\n    shape: {\n        // Start point\n        x1: 0,\n        y1: 0,\n        // End point\n        x2: 0,\n        y2: 0,\n\n        percent: 1\n    },\n\n    style: {\n        stroke: '#000000',\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        var x1 = shape.x1;\n        var y1 = shape.y1;\n        var x2 = shape.x2;\n        var y2 = shape.y2;\n        var percent = shape.percent;\n\n        if (percent === 0) {\n            return;\n        }\n\n        ctx.moveTo(x1, y1);\n\n        if (percent < 1) {\n            x2 = x1 * (1 - percent) + x2 * percent;\n            y2 = y1 * (1 - percent) + y2 * percent;\n        }\n        ctx.lineTo(x2, y2);\n    },\n\n    /**\n     * Get point at percent\n     * @param  {number} percent\n     * @return {Array.<number>}\n     */\n    pointAt: function (p) {\n        var shape = this.shape;\n        return [\n            shape.x1 * (1 - p) + shape.x2 * p,\n            shape.y1 * (1 - p) + shape.y2 * p\n        ];\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Line.js\n// module id = 40\n// module chunks = 0 1","/**\n * @module zrender/graphic/shape/Polyline\n */\n\nvar polyHelper = require('../helper/poly');\n\nmodule.exports = require('../Path').extend({\n\n    type: 'polyline',\n\n    shape: {\n        points: null,\n\n        smooth: false,\n\n        smoothConstraint: null\n    },\n\n    style: {\n        stroke: '#000000',\n\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        polyHelper.buildPath(ctx, shape, false);\n    }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Polyline.js\n// module id = 41\n// module chunks = 0 1","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/helper/poly.js\n// module id = 42\n// module chunks = 0 1","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/helper/smoothSpline.js\n// module id = 43\n// module chunks = 0 1","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/helper/smoothBezier.js\n// module id = 44\n// module chunks = 0 1","/**\n * \n * @module zrender/shape/Polygon\n */\n\nvar polyHelper = require('../helper/poly');\n\nmodule.exports = require('../Path').extend({\n\n    type: 'polygon',\n\n    shape: {\n        points: null,\n\n        smooth: false,\n\n        smoothConstraint: null\n    },\n\n    buildPath: function (ctx, shape) {\n        polyHelper.buildPath(ctx, shape, true);\n    }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Polygon.js\n// module id = 45\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\nvar roundRectHelper = require('../helper/roundRect');\n\nmodule.exports = require('../Path').extend({\n\n    type: 'rect',\n\n    shape: {\n        // r1r2r3r4\n        // r1          [1, 1, 1, 1]\n        // r[1]        [1, 1, 1, 1]\n        // r[1, 2]     [1, 2, 1, 2]\n        // r[1, 2, 3]  [1, 2, 3, 2]\n        r: 0,\n\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var x = shape.x;\n        var y = shape.y;\n        var width = shape.width;\n        var height = shape.height;\n        if (!shape.r) {\n            ctx.rect(x, y, width, height);\n        }\n        else {\n            roundRectHelper.buildPath(ctx, shape);\n        }\n        ctx.closePath();\n        return;\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Rect.js\n// module id = 46\n// module chunks = 0 1","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/helper/roundRect.js\n// module id = 47\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\nmodule.exports = require('../Path').extend({\n\n    type: 'ring',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        r: 0,\n        r0: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var x = shape.cx;\n        var y = shape.cy;\n        var PI2 = Math.PI * 2;\n        ctx.moveTo(x + shape.r, y);\n        ctx.arc(x, y, shape.r, 0, PI2, false);\n        ctx.moveTo(x + shape.r0, y);\n        ctx.arc(x, y, shape.r0, 0, PI2, true);\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Ring.js\n// module id = 48\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Rose\n */\n\nvar sin = Math.sin;\nvar cos = Math.cos;\nvar radian = Math.PI / 180;\n\nmodule.exports = require('../Path').extend({\n\n    type: 'rose',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        r: [],\n        k: 0,\n        n: 1\n    },\n\n    style: {\n        stroke: '#000000',\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        var x;\n        var y;\n        var R = shape.r;\n        var r;\n        var k = shape.k;\n        var n = shape.n;\n\n        var x0 = shape.cx;\n        var y0 = shape.cy;\n\n        ctx.moveTo(x0, y0);\n\n        for (var i = 0, len = R.length; i < len; i++) {\n            r = R[i];\n\n            for (var j = 0; j <= 360 * n; j++) {\n                x = r\n                    * sin(k / n * j % 360 * radian)\n                    * cos(j * radian)\n                    + x0;\n                y = r\n                    * sin(k / n * j % 360 * radian)\n                    * sin(j * radian)\n                    + y0;\n                ctx.lineTo(x, y);\n            }\n        }\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Rose.js\n// module id = 49\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\nvar Path = require('../Path');\n\nmodule.exports = Path.extend({\n\n    type: 'sector',\n\n    shape: {\n\n        cx: 0,\n\n        cy: 0,\n\n        r0: 0,\n\n        r: 0,\n\n        startAngle: 0,\n\n        endAngle: Math.PI * 2,\n\n        clockwise: true\n    },\n\n    buildPath: function (ctx, shape) {\n\n        var x = shape.cx;\n        var y = shape.cy;\n        var r0 = Math.max(shape.r0 || 0, 0);\n        var r = Math.max(shape.r, 0);\n        var startAngle = shape.startAngle;\n        var endAngle = shape.endAngle;\n        var clockwise = shape.clockwise;\n\n        var unitX = Math.cos(startAngle);\n        var unitY = Math.sin(startAngle);\n\n        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n        ctx.lineTo(unitX * r + x, unitY * r + y);\n\n        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n        ctx.lineTo(\n            Math.cos(endAngle) * r0 + x,\n            Math.sin(endAngle) * r0 + y\n        );\n\n        if (r0 !== 0) {\n            ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n        }\n\n        ctx.closePath();\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Sector.js\n// module id = 50\n// module chunks = 0 1","/**\n * nn>3\n * @module zrender/graphic/shape/Star\n */\n\nvar PI = Math.PI;\n\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nmodule.exports = require('../Path').extend({\n\n    type: 'star',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        n: 3,\n        r0: null,\n        r: 0\n    },\n\n    buildPath: function (ctx, shape) {\n\n        var n = shape.n;\n        if (!n || n < 2) {\n            return;\n        }\n\n        var x = shape.cx;\n        var y = shape.cy;\n        var r = shape.r;\n        var r0 = shape.r0;\n\n        // \n        if (r0 == null) {\n            r0 = n > 4\n                // \n                // r0\n                ? r * cos(2 * PI / n) / cos(PI / n)\n                // \n                : r / 3;\n        }\n\n        var dStep = PI / n;\n        var deg = -PI / 2;\n        var xStart = x + r * cos(deg);\n        var yStart = y + r * sin(deg);\n        deg += dStep;\n\n        // inside\n        ctx.moveTo(xStart, yStart);\n        for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\n            ri = i % 2 === 0 ? r0 : r;\n            ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));\n            deg += dStep;\n        }\n\n        ctx.closePath();\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Star.js\n// module id = 51\n// module chunks = 0 1","/**\n * \n * @module zrender/graphic/shape/Trochoid\n */\n\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nmodule.exports = require('../Path').extend({\n\n    type: 'trochoid',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        r: 0,\n        r0: 0,\n        d: 0,\n        location: 'out'\n    },\n\n    style: {\n        stroke: '#000000',\n\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        var x1;\n        var y1;\n        var x2;\n        var y2;\n        var R = shape.r;\n        var r = shape.r0;\n        var d = shape.d;\n        var offsetX = shape.cx;\n        var offsetY = shape.cy;\n        var delta = shape.location == 'out' ? 1 : -1;\n\n        if (shape.location && R <= r) {\n            return;\n        }\n\n        var num = 0;\n        var i = 1;\n        var theta;\n\n        x1 = (R + delta * r) * cos(0)\n            - delta * d * cos(0) + offsetX;\n        y1 = (R + delta * r) * sin(0)\n            - d * sin(0) + offsetY;\n\n        ctx.moveTo(x1, y1);\n\n        // i\n        do {\n            num++;\n        }\n        while ((r * num) % (R + delta * r) !== 0);\n\n        do {\n            theta = Math.PI / 180 * i;\n            x2 = (R + delta * r) * cos(theta)\n                - delta * d * cos((R / r + delta) * theta)\n                + offsetX;\n            y2 = (R + delta * r) * sin(theta)\n                - d * sin((R / r + delta) * theta)\n                + offsetY;\n            ctx.lineTo(x2, y2);\n            i++;\n        }\n        while (i <= (r * num) / (R + delta * r) * 360);\n\n    }\n});\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/shape/Trochoid.js\n// module id = 52\n// module chunks = 0 1","/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n\n    this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n\n    constructor: Gradient,\n\n    addColorStop: function (offset, color) {\n        this.colorStops.push({\n\n            offset: offset,\n\n            color: color\n        });\n    }\n};\n\nmodule.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Gradient.js\n// module id = 53\n// module chunks = 0 1","'use strict';\n\n\nvar zrUtil = require('../core/util');\n\nvar Gradient = require('./Gradient');\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n    this.x = x == null ? 0 : x;\n\n    this.y = y == null ? 0 : y;\n\n    this.x2 = x2 == null ? 1 : x2;\n\n    this.y2 = y2 == null ? 0 : y2;\n\n    // Can be cloned\n    this.type = 'linear';\n\n    // If use global coord\n    this.global = globalCoord || false;\n\n    Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n\n    constructor: LinearGradient\n};\n\nzrUtil.inherits(LinearGradient, Gradient);\n\nmodule.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/LinearGradient.js\n// module id = 54\n// module chunks = 0 1","'use strict';\n\n\nvar zrUtil = require('../core/util');\n\nvar Gradient = require('./Gradient');\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n    this.x = x == null ? 0.5 : x;\n\n    this.y = y == null ? 0.5 : y;\n\n    this.r = r == null ? 0.5 : r;\n\n    // Can be cloned\n    this.type = 'radial';\n\n    // If use global coord\n    this.global = globalCoord || false;\n\n    Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n\n    constructor: RadialGradient\n};\n\nzrUtil.inherits(RadialGradient, Gradient);\n\nmodule.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/RadialGradient.js\n// module id = 55\n// module chunks = 0 1","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\nvar Displayable = require('./Displayable');\nvar zrUtil = require('../core/util');\nvar textContain = require('../contain/text');\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n    Displayable.call(this, opts);\n};\n\nText.prototype = {\n\n    constructor: Text,\n\n    type: 'text',\n\n    brush: function (ctx, prevEl) {\n        var style = this.style;\n        var x = style.x || 0;\n        var y = style.y || 0;\n        // Convert to string\n        var text = style.text;\n\n        // Convert to string\n        text != null && (text += '');\n\n        // Always bind style\n        style.bind(ctx, this, prevEl);\n\n        if (text) {\n\n            this.setTransform(ctx);\n\n            var textBaseline;\n            var textAlign = style.textAlign;\n            var font = style.textFont || style.font;\n            if (style.textVerticalAlign) {\n                var rect = textContain.getBoundingRect(\n                    text, font, style.textAlign, 'top'\n                );\n                // Ignore textBaseline\n                textBaseline = 'middle';\n                switch (style.textVerticalAlign) {\n                    case 'middle':\n                        y -= rect.height / 2 - rect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= rect.height - rect.lineHeight / 2;\n                        break;\n                    default:\n                        y += rect.lineHeight / 2;\n                }\n            }\n            else {\n                textBaseline = style.textBaseline;\n            }\t\t\t\n\t\t\n            // TODO Invalid font\t\t\t\n\t\t\tvar fontSize = parseInt(\n\t\t\t\t(font || '18 simsun').split(' ')[0].replace('px', ''));\n\t\t\tctx.setFontSize(fontSize);\n\n            ctx.textAlign = textAlign || 'left';\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            if (ctx.textAlign !== textAlign) {\n                ctx.textAlign = 'left';\n            }\n            ctx.textBaseline = textBaseline || 'alphabetic';\n            // Use canvas default alphabetic baseline\n            if (ctx.textBaseline !== textBaseline) {\n                ctx.textBaseline = 'alphabetic';\n            }\n\n            var lineHeight = textContain.measureText('', fontSize).width;\n\n            var textLines = text.split('\\n');\n            for (var i = 0; i < textLines.length; i++) {\n                \n                style.hasFill() && ctx.fillText(textLines[i], x, y);\n                \n                style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                y += lineHeight;\n            }\n\n            this.restoreTransform(ctx);\n        }\n    },\n\n    getBoundingRect: function () {\n        if (!this._rect) {\n            var style = this.style;\n            var textVerticalAlign = style.textVerticalAlign;\n            var rect = textContain.getBoundingRect(\n                style.text + '', style.textFont || style.font, style.textAlign,\n                textVerticalAlign ? 'top' : style.textBaseline\n            );\n            switch (textVerticalAlign) {\n                case 'middle':\n                    rect.y -= rect.height / 2;\n                    break;\n                case 'bottom':\n                    rect.y -= rect.height;\n                    break;\n            }\n            rect.x += style.x || 0;\n            rect.y += style.y || 0;\n            this._rect = rect;\n        }\n        return this._rect;\n    }\n};\n\nzrUtil.inherits(Text, Displayable);\n\nmodule.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Text.js\n// module id = 56\n// module chunks = 0 1","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\nvar Displayable = require('./Displayable');\nvar BoundingRect = require('../core/BoundingRect');\nvar zrUtil = require('../core/util');\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n    Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n\n    constructor: ZImage,\n\n    type: 'image',\n\n    brush: function (ctx, prevEl) {\n        var style = this.style;\n        var image = style.image;\n\n        // Must bind each time\n        style.bind(ctx, this, prevEl);\n\n        var width = style.width;\n        var height = style.height;\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        // transform\n        this.setTransform(ctx);\n\n        ctx.drawImage(\n            image,\n            x, y, width, height\n        );\n\n        // Draw rect text\n        if (style.text != null) {\n            this.drawRectText(ctx, this.getBoundingRect());\n        }\n\n    },\n\n    getBoundingRect: function () {\n        var style = this.style;\n        if (!this._rect) {\n            this._rect = new BoundingRect(\n                style.x || 0, style.y || 0, style.width || 0, style.height || 0\n            );\n        }\n        return this._rect;\n    }\n};\n\nzrUtil.inherits(ZImage, Displayable);\n\nmodule.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/graphic/Image.js\n// module id = 57\n// module chunks = 0 1","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\nvar util = require('../core/util');\nvar Dispatcher = require('../core/event').Dispatcher;\n\nvar requestAnimationFrame = require('./requestAnimationFrame');\n\nvar Animator = require('./Animator');\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n\n    options = options || {};\n\n    this.stage = options.stage || {};\n\n    this.onframe = options.onframe || function () { };\n\n    // private properties\n    this._clips = [];\n\n    this._running = false;\n\n    this._time;\n\n    this._pausedTime;\n\n    this._pauseStart;\n\n    this._paused = false;\n\n    Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n\n    constructor: Animation,\n    /**\n     *  clip\n     * @param {module:zrender/animation/Clip} clip\n     */\n    addClip: function (clip) {\n        this._clips.push(clip);\n    },\n    /**\n     *  animator\n     * @param {module:zrender/animation/Animator} animator\n     */\n    addAnimator: function (animator) {\n        animator.animation = this;\n        var clips = animator.getClips();\n        for (var i = 0; i < clips.length; i++) {\n            this.addClip(clips[i]);\n        }\n    },\n    /**\n     * \n     * @param {module:zrender/animation/Clip} clip\n     */\n    removeClip: function (clip) {\n        var idx = util.indexOf(this._clips, clip);\n        if (idx >= 0) {\n            this._clips.splice(idx, 1);\n        }\n    },\n\n    /**\n     * \n     * @param {module:zrender/animation/Animator} animator\n     */\n    removeAnimator: function (animator) {\n        var clips = animator.getClips();\n        for (var i = 0; i < clips.length; i++) {\n            this.removeClip(clips[i]);\n        }\n        animator.animation = null;\n    },\n\n    _update: function () {\n\n\n        var time = new Date().getTime() - this._pausedTime;\n        var delta = time - this._time;\n        var clips = this._clips;\n        var len = clips.length;\n\n        var deferredEvents = [];\n        var deferredClips = [];\n        for (var i = 0; i < len; i++) {\n            var clip = clips[i];\n            var e = clip.step(time);\n            // Throw out the events need to be called after\n            // stage.update, like destroy\n            if (e) {\n                deferredEvents.push(e);\n                deferredClips.push(clip);\n            }\n        }\n\n        // Remove the finished clip\n        for (var i = 0; i < len;) {\n            if (clips[i]._needsRemove) {\n                clips[i] = clips[len - 1];\n                clips.pop();\n                len--;\n            }\n            else {\n                i++;\n            }\n        }\n\n        len = deferredEvents.length;\n        for (var i = 0; i < len; i++) {\n            deferredClips[i].fire(deferredEvents[i]);\n        }\n\n        this._time = time;\n\n        this.onframe(delta);\n\n        this.trigger('frame', delta);\n\n\t\t\n        if (this.stage.update) {\n            this.stage.update();\n        }\n\t\t\n    },\n\n    _startLoop: function () {\n        var self = this;\n\n        this._running = true;\n\n        function step() {\n            if (self._running) {\n\n                requestAnimationFrame(step);\n\n                !self._paused && self._update();\n            }\n        }\n\n        requestAnimationFrame(step);\n    },\n\n    /**\n     * \n     */\n    start: function () {\n\n        this._time = new Date().getTime();\n        this._pausedTime = 0;\n\n        this._startLoop();\n    },\n    /**\n     * \n     */\n    stop: function () {\n        this._running = false;\n    },\n\n    /**\n     * Pause\n     */\n    pause: function () {\n        if (!this._paused) {\n            this._pauseStart = new Date().getTime();\n            this._paused = true;\n        }\n    },\n\n    /**\n     * Resume\n     */\n    resume: function () {\n        if (this._paused) {\n            this._pausedTime += (new Date().getTime()) - this._pauseStart;\n            this._paused = false;\n        }\n    },\n\n    /**\n     * \n     */\n    clear: function () {\n        this._clips = [];\n    },\n    /**\n     * animator\n     * @param  {Object} target\n     * @param  {Object} options\n     * @param  {boolean} [options.loop=false] \n     * @param  {Function} [options.getter=null]\n     *         gettergetter\n     * @param  {Function} [options.setter=null]\n     *         settersetter\n     * @return {module:zrender/animation/Animation~Animator}\n     */\n    // TODO Gap\n    animate: function (target, options) {\n        options = options || {};\n        var animator = new Animator(\n            target,\n            options.loop,\n            options.getter,\n            options.setter\n        );\n\n        return animator;\n    }\n};\n\nutil.mixin(Animation, Dispatcher);\n\nmodule.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/animation/Animation.js\n// module id = 58\n// module chunks = 0 1","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');   \n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || true) {\n            defaultGetZrXY(el, e, out);\n        }       \n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {    \n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n       \n        el.attachEvent('on' + name, handler);\n    }\n\n    function removeEventListener(el, name, handler) {\n      \n        el.detachEvent('on' + name, handler);\n\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/event.js\n// module id = 59\n// module chunks = 0 1","\nmodule.exports = function (func) {\n    setTimeout(func, 16);\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/animation/requestAnimationFrame.js\n// module id = 60\n// module chunks = 0 1","// Global defines\n\nvar guid = require('./core/guid');\nvar zrUtil = require('./core/util');\nvar Handler = require('./Handler');\nvar Storage = require('./Storage');\nvar Animation = require('./animation/Animation');\nvar log = require('./core/log');\n\nvar painterCtors = {\n    canvas: require('./Painter')\n};\n\nvar instances = {};    // ZRendermap\n\nvar zrender = {};\n\n/**\n * @type {string}\n */\nzrender.version = 'WeZRender';\n\n/*** we\n * Initializing a zrender instance\n * @param {string} id\n * @param {number} width \n * @param {number} height\n * @return {module:zrender/ZRender}\n */\nzrender.init = function (id, width, height) {\n    var dom = {\n        id: id,\n        width: width,\n        height: height,\n        context: null,\n        getContext: function () {\n            if (!this.context) {\n                var ctx = wx.createCanvasContext(this.id);\n                ctx.id = this.id;\n\t\t\t\t\n                if (!ctx.setTransform) {\n                    ctx.setTransform = function () { }\n                }\n\t\t\t\t\n\t\t\t\tif (!ctx.setTransform) {\n\t\t\t\t\t ctx.measureText = {\n                    \n\t\t\t\t\t};\n\t\t\t\t}               \n\t\t\t\t\n                this.context = ctx;\n            }\n            return this.context;\n        }\n    };\n    var opts = {};\n    var zr = new ZRender(guid(), dom, opts);\n    instances[zr.id] = zr;\n    return zr;\n};\n/*** we ***/\n\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\nzrender.dispose = function (zr) {\n    if (zr) {\n        zr.dispose();\n    }\n    else {\n        for (var key in instances) {\n            if (instances.hasOwnProperty(key)) {\n                instances[key].dispose();\n            }\n        }\n        instances = {};\n    }\n\n    return zrender;\n};\n\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\nzrender.getInstance = function (id) {\n    return instances[id];\n};\n\nzrender.registerPainter = function (name, Ctor) {\n    painterCtors[name] = Ctor;\n};\n\nfunction delInstance(id) {\n    delete instances[id];\n}\n\n/**\n * @module zrender/ZRender\n */\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {Object} dom\n * @param {Object} opts\n */\nvar ZRender = function (id, dom, opts) {\n\n    opts = opts || {};\n\n    /**\n     * @type {Object}\n     */\n    this.dom = dom;\n\n    /**\n     * @type {string}\n     */\n    this.id = id;\n\n    var self = this;\n    var storage = new Storage();\n\n    var rendererType = 'canvas';\n\n    var painter = new painterCtors[rendererType](dom, storage, opts);\n\n    this.storage = storage;\n    this.painter = painter;\n\n    var handlerProxy = null;\n\n    this.handler = new Handler(storage, painter, handlerProxy, painter.root);\n\n    /**\n     * @type {module:zrender/animation/Animation}\n     */\n    this.animation = new Animation({\n        stage: {\n            update: zrUtil.bind(this.flush, this)\n        }\n    });\n    this.animation.start();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this._needsRefresh;\n\n    //  storage.delFromMap, \n    // FIXME ugly\n    var oldDelFromMap = storage.delFromMap;\n    var oldAddToMap = storage.addToMap;\n\n    storage.delFromMap = function (elId) {\n        var el = storage.get(elId);\n\n        oldDelFromMap.call(storage, elId);\n\n        el && el.removeSelfFromZr(self);\n    };\n\n    storage.addToMap = function (el) {\n        oldAddToMap.call(storage, el);\n\n        el.addSelfToZr(self);\n    };\n};\n\nZRender.prototype = {\n\n    constructor: ZRender,\n    /**\n     * \n     * @return {string}\n     */\n    getId: function () {\n        return this.id;\n    },\n\n    /**\n     * \n     * @param  {module:zrender/Element} el\n     */\n    add: function (el) {\n        this.storage.addRoot(el);\n        this._needsRefresh = true;\n    },\n\n    /**\n     * \n     * @param  {module:zrender/Element} el\n     */\n    remove: function (el) {\n        this.storage.delRoot(el);\n        this._needsRefresh = true;\n    },\n\n     /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n\n    /**\n     * Repaint the canvas immediately\n     */\n    refreshImmediately: function () {\n        // Clear needsRefresh ahead to avoid something wrong happens in refresh\n        // Or it will cause zrender refreshes again and again.\n        this._needsRefresh = false;\n        this.painter.refresh();\n        /**\n         * Avoid trigger zr.refresh in Element#beforeUpdate hook\n         */\n        this._needsRefresh = false;\n    },\n\n    /**\n     * Mark and repaint the canvas in the next frame of browser\n     */\n    refresh: function () {\n        this._needsRefresh = true;\n    },\n\n    /**\n     * Perform all refresh\n     */\n    flush: function () {\n        if (this._needsRefresh) {\n            this.refreshImmediately();\n        }\n    },\n\n\n    /**\n     * Stop and clear all animation immediately\n     */\n    clearAnimation: function () {\n        this.animation.clear();\n    },\n\n    /**\n     * Get container width\n     */\n    getWidth: function () {\n        return this.painter.getWidth();\n    },\n\n    /**\n     * Get container height\n     */\n    getHeight: function () {\n        return this.painter.getHeight();\n    },\n\n    /**\n     * Bind event\n     *\n     * @param {string} eventName Event name\n     * @param {Function} eventHandler Handler function\n     * @param {Object} [context] Context object\n     */\n    on: function (eventName, eventHandler, context) {\n        this.handler.on(eventName, eventHandler, context);\n    },\n\n    /**\n     * Unbind event\n     * @param {string} eventName Event name\n     * @param {Function} [eventHandler] Handler function\n     */\n    off: function (eventName, eventHandler) {\n        this.handler.off(eventName, eventHandler);\n    },\n\n    /**\n     * Trigger event manually\n     *\n     * @param {string} eventName Event name\n     * @param {event=} event Event object\n     */\n    trigger: function (eventName, event) {\n        this.handler.trigger(eventName, event);\n    },\n\n\n    /**\n     * Clear all objects and the canvas.\n     */\n    clear: function () {\n        this.storage.delRoot();\n        this.painter.clear();\n    },\n\n    /**\n     * Dispose self.\n     */\n    dispose: function () {\n        this.animation.stop();\n\n        this.clear();\n        this.storage.dispose();\n        this.painter.dispose();\n        this.handler.dispose();\n\n        this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n        delInstance(this.id);\n    }\n};\n\nmodule.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/zrender.js\n// module id = 61\n// module chunks = 0 1","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n      \n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Handler.js\n// module id = 62\n// module chunks = 0 1","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/mixin/Draggable.js\n// module id = 63\n// module chunks = 0 1","var util = require('./core/util');\nvar Group = require('./container/Group');\n\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nvar timsort = require('./core/timsort');\n\nfunction shapeCompareFunc(a, b) {\n    if (a.zlevel === b.zlevel) {\n        if (a.z === b.z) {\n            // if (a.z2 === b.z2) {\n            //     // FIXME Slow has renderidx compare\n            //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n            //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n            //     return a.__renderidx - b.__renderidx;\n            // }\n            return a.z2 - b.z2;\n        }\n        return a.z - b.z;\n    }\n    return a.zlevel - b.zlevel;\n}\n/**\n *  (M)\n * @alias module:zrender/Storage\n * @constructor\n */\nvar Storage = function () {\n    // idmap\n    this._elements = {};\n\n    this._roots = [];\n\n    this._displayList = [];\n\n    this._displayListLen = 0;\n};\n\nStorage.prototype = {\n\n    constructor: Storage,\n\n    /**\n     * @param  {Function} cb\n     *\n     */\n    traverse: function (cb, context) {\n        for (var i = 0; i < this._roots.length; i++) {\n            this._roots[i].traverse(cb, context);\n        }\n    },\n\n    /**\n     * \n     * @param {boolean} [update=false] \n     * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n     *\n     * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n     * @return {Array.<module:zrender/graphic/Displayable>}\n     */\n    getDisplayList: function (update, includeIgnore) {\n        includeIgnore = includeIgnore || false;\n        if (update) {\n            this.updateDisplayList(includeIgnore);\n        }\n        return this._displayList;\n    },\n\n    /**\n     * \n     * GroupShapeShape\n     * zlevel > z > \n     * @param {boolean} [includeIgnore=false]  ignore \n     */\n    updateDisplayList: function (includeIgnore) {\n        this._displayListLen = 0;\n        var roots = this._roots;\n        var displayList = this._displayList;\n        for (var i = 0, len = roots.length; i < len; i++) {\n            this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n        }\n        displayList.length = this._displayListLen;\n\n        // for (var i = 0, len = displayList.length; i < len; i++) {\n        //     displayList[i].__renderidx = i;\n        // }\n\n        // displayList.sort(shapeCompareFunc);\n        false && timsort(displayList, shapeCompareFunc);\n    },\n\n    _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n        if (el.ignore && !includeIgnore) {\n            return;\n        }\n\n        el.beforeUpdate();\n\n        if (el.__dirty) {\n\n            el.update();\n\n        }\n\n        el.afterUpdate();\n\n        /*** we\n        var clipPath = el.clipPath;\n        if (clipPath) {\n            // clipPath  group \n            clipPath.parent = el;\n            clipPath.updateTransform();\n\n            // FIXME \n            if (clipPaths) {\n                clipPaths = clipPaths.slice();\n                clipPaths.push(clipPath);\n            }\n            else {\n                clipPaths = [clipPath];\n            }\n        }\n        we ***/\n\n        /*** we ***/\n        var userSetClipPath = el.clipPath;\n        if (userSetClipPath) {\n\n            // FIXME \n            if (clipPaths) {\n                clipPaths = clipPaths.slice();\n            }\n            else {\n                clipPaths = [];\n            }\n\n            var currentClipPath = userSetClipPath;\n            var parentClipPath = el;\n            // Recursively add clip path\n            while (currentClipPath) {\n                // clipPath  clipPath \n                currentClipPath.parent = parentClipPath;\n                currentClipPath.updateTransform();\n\n                clipPaths.push(currentClipPath);\n\n                parentClipPath = currentClipPath;\n                currentClipPath = currentClipPath.clipPath;\n            }\n        }\n        /*** we ***/\n\n        if (el.isGroup) {\n            var children = el._children;\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n\n                // Force to mark as dirty if group is dirty\n                // FIXME __dirtyPath ?\n                if (el.__dirty) {\n                    child.__dirty = true;\n                }\n\n                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n            }\n\n            // Mark group clean here\n            el.__dirty = false;\n\n        }\n        else {\n            el.__clipPaths = clipPaths;\n\n            this._displayList[this._displayListLen++] = el;\n        }\n    },\n\n    /**\n     * (Shape)(Group)\n     * @param {module:zrender/Element} el\n     */\n    addRoot: function (el) {\n        // Element has been added\n        if (this._elements[el.id]) {\n            return;\n        }\n\n        if (el instanceof Group) {\n            el.addChildrenToStorage(this);\n        }\n\n        this.addToMap(el);\n        this._roots.push(el);\n    },\n\n    /**\n     * (Shape)(Group)\n     * @param {string|Array.<string>} [elId] Storage\n     */\n    delRoot: function (elId) {\n        if (elId == null) {\n            // elId\n            for (var i = 0; i < this._roots.length; i++) {\n                var root = this._roots[i];\n                if (root instanceof Group) {\n                    root.delChildrenFromStorage(this);\n                }\n            }\n\n            this._elements = {};\n            this._roots = [];\n            this._displayList = [];\n            this._displayListLen = 0;\n\n            return;\n        }\n\n        if (elId instanceof Array) {\n            for (var i = 0, l = elId.length; i < l; i++) {\n                this.delRoot(elId[i]);\n            }\n            return;\n        }\n\n        var el;\n        if (typeof (elId) == 'string') {\n            el = this._elements[elId];\n        }\n        else {\n            el = elId;\n        }\n\n        var idx = util.indexOf(this._roots, el);\n        if (idx >= 0) {\n            this.delFromMap(el.id);\n            this._roots.splice(idx, 1);\n            if (el instanceof Group) {\n                el.delChildrenFromStorage(this);\n            }\n        }\n    },\n\n    addToMap: function (el) {\n        if (el instanceof Group) {\n            el.__storage = this;\n        }\n        el.dirty(false);\n\n        this._elements[el.id] = el;\n\n        return this;\n    },\n\n    get: function (elId) {\n        return this._elements[elId];\n    },\n\n    delFromMap: function (elId) {\n        var elements = this._elements;\n        var el = elements[elId];\n        if (el) {\n            delete elements[elId];\n            if (el instanceof Group) {\n                el.__storage = null;\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Storage\n     */\n    dispose: function () {\n        this._elements =\n            this._renderList =\n            this._roots = null;\n    },\n\n    displayableSortFunc: shapeCompareFunc\n};\n\nmodule.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Storage.js\n// module id = 64\n// module chunks = 0 1","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/timsort.js\n// module id = 65\n// module chunks = 0 1","var config = require('./config');\nvar util = require('./core/util');\nvar log = require('./core/log');\nvar BoundingRect = require('./core/BoundingRect');\nvar timsort = require('./core/timsort');\nvar Layer = require('./Layer');\n\nfunction parseInt10(val) {\n    return parseInt(val, 10);\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n    tmpRect.copy(el.getBoundingRect());\n    if (el.transform) {\n        tmpRect.applyTransform(el.transform);\n    }\n    viewRect.width = width;\n    viewRect.height = height;\n    return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n    if (clipPaths == prevClipPaths) { // Can both be null or undefined\n        return false;\n    }\n\n    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n        return true;\n    }\n    for (var i = 0; i < clipPaths.length; i++) {\n        if (clipPaths[i] !== prevClipPaths[i]) {\n            return true;\n        }\n    }\n}\n\nfunction doClip(clipPaths, ctx) {\n\t/*** we\n    for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var path = clipPath.path;\n\n        clipPath.setTransform(ctx);\n        path.beginPath(ctx);\n        clipPath.buildPath(path, clipPath.shape);\n        ctx.clip();\n        // Transform back\n        clipPath.restoreTransform(ctx);\n    }\n\twe ***/\n}\n\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {Object} root \n * @param {module:zrender/Storage} storage\n * @param {Ojbect} opts\n */\nvar Painter = function (root, storage, opts) {\n\n\n    this._opts = opts = util.extend({}, opts || {});\n\n    /**\n     * @type {number}\n     */\n    this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\n    /**\n     * \n     * @type {Object}\n     */\n    this.root = root;\n\n    /**\n     * @type {module:zrender/Storage}\n     */\n    this.storage = storage;\n\n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    var zlevelList = this._zlevelList = [];\n\n    /**\n     * @type {Object.<string, module:zrender/Layer>}\n     * @private\n     */\n    var layers = this._layers = {};\n\n    /**\n     * @type {Object.<string, Object>}\n     * @type {private}\n     */\n    this._layerConfig = {};\n\n\n    // Use canvas width and height directly\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height;\n\n    // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext();\n    // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n\n};\n\nPainter.prototype = {\n\n    constructor: Painter,\n\n    /**\n     * @return {HTMLDivElement}\n     */\n    getViewportRoot: function () {\n        return this._layers[0].dom;\n    },\n\n    /**\n     * \n     * @param {boolean} [paintAll=false] displayable\n     */\n    refresh: function (paintAll) {\n\t\t\n        var list = this.storage.getDisplayList(true);\t\n\t\t\n        this._paintList(list, paintAll);       \n\n        return this;\n    },\n\n\n    _paintList: function (list, paintAll) {\n\n        if (paintAll == null) {\n            paintAll = false;\n        }\n\n        this._doPaintList(list, paintAll);\n    },\n\n    _doPaintList: function (list, paintAll) {\n\t\t\n        var currentLayer;\n        var currentZLevel;\n        var ctx;\n\n        // var invTransform = [];\n        var scope;\n\n        var width = this._width;\n        var height = this._height;\n\n        for (var i = 0, l = list.length; i < l; i++) {\n            var el = list[i];\n            var elZLevel = 0;\n\n            var elFrame = el.__frame;\n\n            // Change draw layer\n            if (currentZLevel !== elZLevel) {\n                if (ctx) {\n                    ctx.restore();\n                }\n\n                // Reset scope\n                scope = {};\n\n                // Only 0 zlevel if only has one canvas\n                currentZLevel = elZLevel;\n                currentLayer = this.getLayer(currentZLevel);\n\n                ctx = currentLayer.ctx;\n                ctx.save();\n\n                // Reset the count\n                currentLayer.__unusedCount = 0;\n\n                if (currentLayer.__dirty || paintAll) {\n                    currentLayer.clear();\n                }\n            }\n\n            if (!(currentLayer.__dirty || paintAll)) {\n                continue;\n            }\n\n            if (elFrame >= 0) {\n\n            }\n            else {\n                this._doPaintEl(el, currentLayer, paintAll, scope);\n            }\n\n            el.__dirty = false;\n        }\n\n        // Restore the lastLayer ctx\n        ctx && ctx.restore();\n        // If still has clipping state\n        // if (scope.prevElClipPaths) {\n        //     ctx.restore();\n        // }        \n    },\n\n    _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t\t\n        var ctx = currentLayer.ctx;\n        var m = el.transform;\n        if (\n            (currentLayer.__dirty || forcePaint)\n            // Ignore invisible element\n            && !el.invisible\n            // Ignore transparent element\n            && el.style.opacity !== 0\n            // Ignore scale 0 element, in some environment like node-canvas\n            // Draw a scale 0 element can cause all following draw wrong\n            // And setTransform with scale 0 will cause set back transform failed.\n            && !(m && !m[0] && !m[3])\n            // Ignore culled element\n            && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n        ) {\n\n            var clipPaths = el.__clipPaths;\n\n            // Optimize when clipping on group with several elements\n            if (scope.prevClipLayer !== currentLayer\n                || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n            ) {\n                // If has previous clipping state, restore from it\n                if (scope.prevElClipPaths) {\n                    scope.prevClipLayer.ctx.restore();\n                    scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                    // Reset prevEl since context has been restored\n                    scope.prevEl = null;\n                }\n                // New clipping state\n                if (clipPaths) {\n                    ctx.save();\n                    doClip(clipPaths, ctx);\n                    scope.prevClipLayer = currentLayer;\n                    scope.prevElClipPaths = clipPaths;\n                }\n            }\n            el.beforeBrush && el.beforeBrush(ctx);\n\n            el.brush(ctx, scope.prevEl || null);\n            scope.prevEl = el;\n\n\t\t\t\n            /*** we ***/\n            ctx.draw(true);\n            /*** we ***/\n\n            el.afterBrush && el.afterBrush(ctx);\n        }\n    },\n\n    /**\n     *  zlevel \n     * @param {number} zlevel\n     * @return {module:zrender/Layer}\n     */\n    getLayer: function (zlevel) {\n        return this._layers[0];\n    },\n\n    // Iterate each layer\n    eachLayer: function (cb, context) {\n        var zlevelList = this._zlevelList;\n        var z;\n        var i;\n        for (i = 0; i < zlevelList.length; i++) {\n            z = zlevelList[i];\n            cb.call(context, this._layers[z], z);\n        }\n    },\n\n    // Iterate each buildin layer\n    eachBuildinLayer: function (cb, context) {\n        var zlevelList = this._zlevelList;\n        var layer;\n        var z;\n        var i;\n        for (i = 0; i < zlevelList.length; i++) {\n            z = zlevelList[i];\n            layer = this._layers[z];\n            if (layer.isBuildin) {\n                cb.call(context, layer, z);\n            }\n        }\n    },\n\n    // Iterate each other layer except buildin layer\n    eachOtherLayer: function (cb, context) {\n        var zlevelList = this._zlevelList;\n        var layer;\n        var z;\n        var i;\n        for (i = 0; i < zlevelList.length; i++) {\n            z = zlevelList[i];\n            layer = this._layers[z];\n            if (!layer.isBuildin) {\n                cb.call(context, layer, z);\n            }\n        }\n    },\n\n    /**\n     * \n     * @param {Array.<module:zrender/Layer>} [prevLayer]\n     */\n    getLayers: function () {\n        return this._layers;\n    },\n\n    /**\n     * hover\n     */\n    clear: function () {\n        this.eachBuildinLayer(this._clearLayer);\n        return this;\n    },\n\n    _clearLayer: function (layer) {\n        layer.clear();\n    },\n\n /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n    /**\n     * \n     */\n    dispose: function () {\n        this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n    },\n\n\n    /**\n     * \n     */\n    getWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * \n     */\n    getHeight: function () {\n        return this._height;\n    }\n};\n\nmodule.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Painter.js\n// module id = 66\n// module chunks = 0 1","var util = require('./core/util');\nvar config = require('./config');\nvar Style = require('./graphic/Style');\nvar Pattern = require('./graphic/Pattern');\nvar log = require('./core/log');\n\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {Object} dom\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\nvar Layer = function (dom, painter, dpr) {\n\n    this.id = dom.id;\n    this.dom = dom;\n\n    this.ctxBack = null;\n\n    this.painter = painter;\n\n    this.config = null;\n\n    // Configs\n    /**\n     * \n     * @type {string}\n     * @default 0\n     */\n    this.clearColor = 0;\n    /**\n     * \n     * @type {boolean}\n     * @default false\n     */\n    this.motionBlur = false;\n    /**\n     * alpha\n     * @type {number}\n     * @default 0.7\n     */\n    this.lastFrameAlpha = 0.7;\n\n    /**\n     * Layer dpr\n     * @type {number}\n     */\n    this.dpr = dpr;\n};\n\nLayer.prototype = {\n\n    constructor: Layer,\n\n    elCount: 0,\n\n    __dirty: true,\n\n    initContext: function () {\n        this.ctx = this.dom.getContext('2d');\n\n        this.ctx.dpr = this.dpr;\n    },\n    \n    /**\n     * \n     * @param {boolean} clearAll Clear all with out motion blur\n     */\n    clear: function (clearAll) {\n        var dom = this.dom;\n        var ctx = this.ctx;\n        var width = dom.width;\n        var height = dom.height;\n\n        var clearColor = this.clearColor;\n\n        var lastFrameAlpha = this.lastFrameAlpha;\n\n        var dpr = this.dpr;\n\n        ctx.clearRect(0, 0, width, height);\n        if (clearColor) {\n            var clearColorGradientOrPattern;\n            // Gradient\n            if (clearColor.colorStops) {\n                // Cache canvas gradient\n                clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height\n                });\n\n                clearColor.__canvasGradient = clearColorGradientOrPattern;\n            }\n            // Pattern\n            else if (clearColor.image) {\n                clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n            }\n            ctx.save();\n            ctx.setFillStyle(clearColorGradientOrPattern || clearColor);\n            ctx.fillRect(0, 0, width, height);\n            ctx.restore();\n        }\n    }\n};\n\nmodule.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Layer.js\n// module id = 67\n// module chunks = 0 1"],"sourceRoot":""}